%! suppress = MissingImport
%! suppress = MissingLabel
%! suppress = LineBreak

% CLI args https://tex.stackexchange.com/a/1501
\newif\ifhandout
\input{flags}

\input{preamble-slides}

\title[2. Рекурсия в $\lambda$-исчислении]{Практика 2. Рекурсия в $\lambda$-исчислении}
\date{осень 2025}

\begin{document}

    \mymaketitle

    \begin{frame}{В предыдущих сериях}
        \begin{itemize}
            \item Синтаксис и семантика $\lambda$-исчисления
            \item Абстракция по данным в $\lambda$-исчислении: кортежи, натуральные числа, логические величины
            \item[\newtopic] Нормальные формы
            \item[\newtopic] Рекурсия и $\comb{Y}$-комбинатор
            \item[\newtopic] Стратегии редукции
        \end{itemize}
    \end{frame}

    \begin{frame}[noframenumbering]{Содержание}
        \tableofcontents
    \end{frame}


    \sectionplan{Ещё метаинформация о курсе}

    \begin{frame}{Зачем изучать ФП/теорию языков программирования}
        \vspace{-0.5em}
        \begin{block}{Для самоопределения}
            \begin{itemize}
                \item ФП~--- лакмусовая бумажка: понравился курс $\Rightarrow$ скорее всего понравится профессионально заниматься языками, в науке или промышленности
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Чтобы быть более хорошими программистами}
            \begin{itemize}
                \item Узнать, что вообще в принципе идейно бывает в языках
                \begin{enumerate}
                    \item Проще изучать новые языки
                    \item Придумываем решение в пространстве возможного
                    \item[\then] А потом аппроксимируем в терминах конкретного языка
                \end{enumerate}
                \item Дисциплинирует ум и учит выбирать более лаконичные и композируемые абстракции
                \item Прививает хорошие практики программирования и аккуратное отношение к эффектам
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Чтобы иметь базу для дальшейшего погружения в науку о языках программирования}
            \begin{itemize}
                \item ФП на пересечении многих областей (вычислимость, доказательства, категории\ldots)
                \item ФП --- неотъемлемая часть академической традиции теории языков программирования
                \item Proof engineering и машинно-проверяемые доказательства --- всё тут
            \end{itemize}
        \end{block}
    \end{frame}

    \begin{frame}{Туториал по прохождению}
        \begin{itemize}
            \item Работайте с эмоциями и держитесь рациональных решений
            \item Старайтесь спокойно относиться к неудачам и работать с их причинами
            \begin{itemize}
                \item Тайм-менеджмент и менеджмент ресурсов
                \item Садитесь за домашки не в последний момент
                \item Старайтесь понять, а не ``натыкать'' задание
            \end{itemize}
            \item Не стесняйтесь просить помощи у преподавателей и одногруппников
            \begin{itemize}
                \item Иногда можно организовывать дополнительную встречу, если с темой у многих проблемы
            \end{itemize}
            \item Повторяйте материал перед парами
            \begin{itemize}
                \item Времени требуется не много, но толку --- куча!
                \item Для практик более-менее достаточно повторить последнюю лекцию
            \end{itemize}
            \item Спите! Иначе всё более-менее без толку
            \item Отдыхайте! Иначе на дистанции вы будете сильно терять в производительности
        \end{itemize}

        \vspace{1em}
        Полезная \href{https://compscicenter.notion.site/compscicenter/b6dddf00bc7d497298179a3bdbdda375}{\color{blue} памятка} от кураторов Computer Science Center.
    \end{frame}


    \sectionplan{Примитивная рекурсия}

    \begin{frame}[fragile]{Цикл по заданному интервалу}
        \begin{itemize}
            \item Любой цикл по интервалу можно записать в следующем виде:
            \begin{minted}{Python}
                def rec(f, ini, n):
                    state = ini
                    for i in range(0, n):
                        state = f(i, state)
                    return state
            \end{minted}
            \item Узнаем общий вид конечного результата с помощью вызова:
            \begin{minted}{python}
                rec(f = lambda i, state: "f(" + str(n) + ", " + state + ")",
                    ini = "z", n =  5} #\pause#
                > "f(4, f(3, f(2, f(1, f(0, z)))))"
            \end{minted}
            \item[\todo] На что похоже?
            \item[\todo] А что если мы хотим обновлять несколько переменных в цикле?
            \item[\answer] \pause На числа Чёрча!
            \item[\answer] \pause Ну будем поддерживать в \mintinline{python}{state} кортеж
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Примитивная рекурсия в $\lambda$-исчислении}
        \begin{block}{Примитивная рекурсия}
            \vspace{-0.5em}

            \[\term{rec}~f~ini~n \eqbeta f~(n-1)~(f~(n-2)~(\cdots~(f~1~(f~0~ini))\cdots))\]
        \end{block}
        \begin{itemize}
            \item Хотим выразить в виде $q\ap (s \ap (s \ap \cdots (s \ap z)\cdots))$, какими будут $q$, $s$ и $z$?
            \item \pause Из итерации в итерацию будем передавать пару: номер итерации; результат предыдущих
            \item Начальное состояние --- $\term{start} \ap ini \termdef \pause \term{pair} \ap \term{0} \ap ini$
            \item \pause Одна итерация:\footnote{Пусть сокращение $\term{pair} \ap i \ap res$ слева значит: принимаем пару $p$, вместо $i$ подразумеваем $\term{fst}\ap p$; $res$ --- $\term{snd}\ap p$.}
            \[
                \term{step} \pause \ap f \ap (\term{pair} \ap i \ap res)
                \termdef
                \term{pair} \ap (\term{suc} \ap i) \ap (f \ap i \ap res)
            \] \vspace{-1em}
            \item \pause Итерирование
            \[
                \term{iter} \ap f \ap ini \ap n
                \termdef
                \pause \term{natElim} \ap n \ap (\term{step} \ap f) \ap (\term{start} \ap ini)
            \] \vspace{-1em}
            \item \pause И наконец
            \[
                \term{rec} \ap f \ap ini \ap n
                \termdef
                \pause \term{snd} \ap (\term{iter} \ap f \ap ini \ap n)
            \] \vspace{-1em}
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Примеры применения примитивной рекурсии}
        \begin{block}{Примитивная рекурсия}
            \vspace{-0.5em}

            \[\term{rec}~f~ini~n \eqbeta f~(n-1)~(f~(n-2)~(\cdots~(f~1~(f~0~ini))\cdots))\]
        \end{block}
        \vspace{1em}
        \begin{itemize}
            \item[\todo] Реализуйте функцию суммирования чисел от $1$ до $n$
            \item[\todo] Реализуйте факториал
            \item[\todo] Реализуйте $\term{pred}$
            \item[\answer] \pause $\term{sum} \ap n \termdef \term{rec} \ap (\lambda i \ap res \ldotp \term{plus} \ap (\term{suc} \ap i) \ap res) \ap \term{0} \ap n$
            \item[\answer] \pause $\term{fac} \ap n
            \termdef
            \term{rec}
            \ap (\lambda i \ap res \ldotp \term{mult} \ap (\term{suc} \ap i) \ap res)
            \ap \term{1} \ap n$
            \item[\answer] \pause $\term{pred} \ap n \termdef \term{rec}~\term{K}~\term{0} \ap n$
            \item Во всех случаях можно сделать $\eta$-редукцию
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Проверка факториала}
        \pause
        \begin{itemize}
            \item $
            \term{fac}~\term{2} \step_{\beta}
            \term{snd}~(\term{2}~(\term{step}~(\lambda i~r\ldotp \term{mult}~(\term{suc}~i)~r))~(\term{pair}~\term{0}~\term{1})) \step_{\beta}
            \term{snd}~(\term{step}~(\lambda i~r\ldotp \term{mult}~(\term{suc}~i)~r)~((\term{step}~(\lambda i~r\ldotp \term{mult}~(\term{suc}~i)~r))~(\term{pair}~\term{0}~\term{1}))) \step_{\beta}
            \term{snd}~(\term{step}~(\lambda i~r\ldotp \term{mult}~(\term{suc}~i)~r)~(\term{pair}~(\term{suc}~\term{0})~((\lambda i~r\ldotp \term{mult}~(\term{suc}~i)~r)~\term{0}~\term{1}))) \step_{\beta}
            \term{snd}~(\term{step}~(\lambda i~r\ldotp \term{mult}~(\term{suc}~i)~r)~(\term{pair}~\term{1}~(\term{mult}~(\term{suc}~\term{0})~\term{1}))) \step_{\beta}
            \term{snd}~(\term{step}~(\lambda i~r\ldotp \term{mult}~(\term{suc}~i)~r)~(\term{pair}~\term{1}~\term{1})) \step_{\beta}
            \term{snd}~(\term{pair}~(\term{suc}~\term{1})~((\lambda i~r\ldotp \term{mult}~(\term{suc}~i)~r)~\term{1}~\term{1})) \step_{\beta}
            (\lambda i~r\ldotp \term{mult}~(\term{suc}~i)~r)~\term{1}~\term{1} \step_{\beta}
            \term{mult}~(\term{suc}~\term{1})~\term{1} \step_{\beta}
            \term{2}
            $
            \item \pause Да ну серьёзно??
            \item \pause Через свойство примитивной рекурсии сильно проще
            \begin{align*}
                \term{fac} \ap \term{3}
                &\step_{\beta} \pause
                f~\term{2}~(
                f~\term{1}~(
                f~\term{0}~\term{1}))
                \\ &\step_{\beta} \pause
                (\lambda i \ap res\ldotp \term{mult}~(\term{suc}~i) \ap res)~\term{2}~(
                f~\term{1}~(
                f~\term{0}~\term{1}))
                \\ &\step_{\beta} \pause
                \term{mult}~(\term{suc}~\term{2})~(
                f~\term{1}~(
                f~\term{0}~\term{1}))
                \\ &\step_{\beta} \pause
                \term{mult}~\term{3}~(
                \term{mult}~\term{2}~(
                \term{mult}~\term{1}~\term{1}))
                \step_{\beta} \pause
                \term{6}
            \end{align*}
            \item Важно грамотно выбирать уровень абстракции
        \end{itemize}
    \end{frame}

    \sectionplan{Рекурсия и комбинаторы неподвижной точки}

    \begin{frame}{Рекурсия}
        \begin{itemize}
            \item Одной примитивной рекурсии в языке недостаточно, чтобы уметь всё
            \item Чтобы добиться полноты, нужна полноценная рекурсия
            \item В прикладные языки рекурсия встроена --- достаточно в теле именованной функции вызвать её саму
            \item Но у нас в языке нет именованных функций, же?!
        \end{itemize}
    \end{frame}

    \begin{frame}{Рекурсивные уравнения на термах}
        Хотим подобрать такой терм $\term{fac}$, чтобы $\term{fac} \ap N \eqbeta \pause \term{if} \ap (\term{iszero} \ap N) \ap \term{1} \ap (\term{mult} \ap N \ap (\term{fac} \ap (\term{pred} \ap N)))$.

        \pause
        \vspace{0.5em}
        Решаем рекурсивное уравнение на термах!
        \begin{enumerate}
            \item \pause Абстрагируемся в правой части по $\term{fac}$ и $N$:
            \[
                \term{fac} \ap N
                \eqbeta
                % https://tex.stackexchange.com/questions/245934/how-can-i-make-underbrace-texts-have-the-normal-text-size
                \underbrace{(\lambda r \ap n \ldotp \term{if} \ap (\term{iszero} \ap \framebox{n}) \ap \term{1} \ap (\term{mult} \ap \framebox{n} \ap (\framebox{r} \ap (\term{pred} \ap \framebox{n}))))}_{\textstyle \term{fac'}}
                \ap \term{fac} \ap N
            \]
            \item \pause Поскольку правые аппликанды совпадают ($N \equiv N$), рассмотрим левые части:
            \[
                \term{fac} \eqt_{\beta} \term{fac'} \ap \term{fac}
            \]
            \item \pause То есть $\term{fac}$ --- неподвижная точка отображения $\term{fac'}$!  Найдём её $\comb{Y}$-комбинатором:
            \[
                \term{fac}
                \termdef \pause
                \comb{Y} \ap \term{fac'}
                \eqt_{\beta} \pause
                \comb{Y} \ap (\lambda r \ap n \ldotp \term{if} \ap (\term{iszero} \ap n) \ap \term{1} \ap (\term{mult} \ap n \ap (r \ap (\term{pred} \ap n))))
            \]
            \vspace{-1em}
            \item \pause Делаем проверку, зная, что $\comb{Y}\ap fac' \eqbeta fac'\ap(\comb{Y}\ap fac')$:
            \begin{align*}
                \term{fac} \ap N
                &\eqbeta \pause
                \comb{Y} \ap \term{fac'} \ap N
                \eqbeta \pause
                \term{fac'} \ap (\comb{Y} \ap \term{fac'}) \ap N
                \\&\eqbeta \pause
                (\lambda r \ap n \ldotp \term{if} \ap (\term{iszero} \ap \framebox{n}) \ap \term{1} \ap (\term{mult} \ap \framebox{n} \ap (\framebox{r} \ap (\term{pred} \ap \framebox{n})))) \ap (\comb{Y} \ap \term{fac'}) \ap N
                \\&\eqbeta \pause
                \term{if} \ap (\term{iszero} \ap \framebox{N}) \ap \term{1} \ap (\term{mult} \ap \framebox{N} \ap (\framebox{$\comb{Y} \ap \term{fac'}$} \ap (\term{pred} \ap \framebox{N})))
            \end{align*}
        \end{enumerate}
    \end{frame}

    \begin{frame}[fragile]{Больше рекурсивных функций!}
        Перепишите через комбинатор неподвижной точки (решите рекурсивные уравнения):
        \begin{itemize}
            \item[\todo] $\term{fib}\ap n\eqbeta\term{if}\ap (\term{le}\ap n\ap \term{2}) \ap\term{1}\ap(\term{plus}\ap(\term{fib}\ap(\term{minus}\ap n\ap\term{1}))\ap(\term{fib}\ap(\term{minus}\ap n\ap \term{2})))$
            \item[\todo] $F\eqbeta M\ap F$
            \item[\answer] \pause $\term{fib} \termdef \comb{Y}\ap\lambda r\ldotp \term{if}\ap (\term{le}\ap n\ap \term{2}) \ap\term{1}\ap(\term{plus}\ap(r\ap(\term{minus}\ap n\ap\term{1}))\ap(r\ap(\term{minus}\ap n \ap\term{2})))$
            \item[\answer] \pause $F \eqbeta \comb{Y}\ap M$
        \end{itemize}
    \end{frame}

    \begin{frame}{Комбинатор рекурсии (неподвижной точки)}
        \pause
        \vspace{-0.5em}
        \begin{block}{Свойство комбинатора неподвижной точки ($\comb{Y}$ --- пример такого комбинатора)}
            \[
                \underbrace{\comb{Y} \ap F}_{\textstyle X} \eqbeta F \ap (\underbrace{\comb{Y} \ap F}_{\textstyle X})
            \]
        \end{block}
        \[
            \term{fac}
            \termdef
            \comb{Y} \ap \underbrace{(\lambda \framebox{r} \ap n \ldotp \term{if} \ap (\term{iszero} \ap n) \ap \term{1} \ap (\term{mult} \ap n \ap (\framebox{r} \ap (\term{pred} \ap n))))}_{\textstyle \term{fac'}}
        \]
        \begin{itemize}
            \item[\todo] Стоп, стоп. Как анонимная функция стала рекурсивной?
            \item[\answer] \pause $\comb{Y}$ передаёт в нашу функцию терм, который ведёт себя ровно так же, как она! %\footnote{Получили конечный терм, который в результате вычислений может сколь угодно разрастаться.}
        \end{itemize}
        \pause
        \begin{block}{Договорённость о рекурсивных синонимах}
            Вводим рекурсию как синтаксический сахар для определения выше:
            \vspace{-0.5em}
            \[
                \term{fac} \ap n
                \termdef
                \term{if} \ap (\term{iszero} \ap n) \ap \term{1} \ap (\term{mult} \ap n \ap (\framebox{$\term{fac}$} \ap (\term{pred} \ap n)))
            \]
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Выбор инструмента: примитивная рекурсия vs рекурсия \practicalslide}
        \begin{itemize}
            \item Примитивная рекурсия
            \begin{itemize}
                \item Задаёт процесс из конечного, заранее заданного, количества шагов
                \item Аналог цикла \mintinline{python}|for in range| в современных языках
            \end{itemize}
            \item Рекурсия
            %! suppress = Ellipsis
            \begin{itemize}
                \item Количество шагов определяется в процессе (и никак иначе: halting problem)
                \item Завершение процесса определяется выполнением произвольного условия (базы рекурсии)
                \item В современных языках выражается рекурсией\footnote{Хвостовая рекурсия полностью эквивалентна обычной, хотя и похожа на примитивную (см. \href{https://en.wikipedia.org/wiki/Trampoline\_(computing)\#High-level_programming}{\color{blue} trampolining}).} и циклом \mintinline{python}|while condition: ...|
            \end{itemize}
            \item Всегда нужно выбирать \emph{наименее могущественный} из подходящих инструментов
            \begin{itemize}
                \item Проще для рассуждений и доказательства свойств
                \item Меньше пространство для ошибок
                \item Скорее всего, код будет эффективнее исполняться
                \item В частности, какие функции примитивно-рекурсивные, а какие --- нет, рассказывает теория вычислимости
            \end{itemize}
        \end{itemize}
    \end{frame}


    \section{Кодирование данных в лямбда-исчислении}

    \subsectionplan{Значения-варианты}

    \begin{frame}[fragile]{\subsecname}
        Одна сущность может быть нескольких различных видов:
        \begin{itemize}
            \item Пользователь может быть авторизованный и не авторизованный
            \item Вершина программы может быть константой, а может --- бинарной операцией
        \end{itemize}
        \vspace{1em}
        Хотим, чтобы в зависимости от её вида, сущность обрабатывал разный код:
        \begin{minted}{python}
            def eval(node):
                if is_const(node):
                    return node.value  # У константы должно быть значение
                elif is_plus(node):
                    return eval(node.left) + eval(node.right)  # У плюса - операнды
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Моделируем значения-варианты}
        \pause
        \begin{block}{API вариантов}
            \begin{itemize}
                \item Один вариант будем называть ``левым'', второй --- ``правым''
                \item Два конструктора $\term{inl}$ и $\term{inr}$
                \item Элиминатор позволяет выполнить разный код в зависимости от варианта: $\term{either}$
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Законы вариантов}
            \begin{enumerate}
                \item $\forall f~g~x \ldotp \term{either} \ap f \ap g \ap (\term{inl} \ap x) \eqbeta f \ap x$
                \item $\forall f~g~y \ldotp \term{either} \ap f \ap g \ap (\term{inr} \ap y) \eqbeta g \ap y$
            \end{enumerate}
        \end{block}
%        \begin{itemize}
%            \item[\tod] Что если нужно закодировать больше двух вариантов?
%        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Тегированное представление вариантов}
        \begin{block}{Законы вариантов}
            \begin{enumerate}
                \item $\forall f~g~x \ldotp \term{either} \ap f \ap g \ap (\term{inl} \ap x) \eqbeta f \ap x$
                \item $\forall f~g~y \ldotp \term{either} \ap f \ap g \ap (\term{inr} \ap y) \eqbeta g \ap y$
            \end{enumerate}
        \end{block}
        \pause
        \begin{block}{Конструкторы}
            \begin{itemize}
                \item Будем приписывать булев тег для различения вариантов
                \item $\term{inl} \ap x \termdef \term{pair} \ap \term{true} \ap x$
                \item $\term{inr} \ap y \termdef \term{pair} \ap \term{false} \ap y$
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Элиминатор}
            \begin{itemize}
                \item Вызвать нужную функцию в зависимости от тега
                \item $\term{either} \ap f \ap g \ap (\term{pair} \ap tag \ap val) \termdef \term{if} \ap tag \ap (f \ap val) \ap (g \ap val)$
            \end{itemize}
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Кодирование вариантов Чёрча}
        \begin{block}{Законы вариантов}
            \begin{enumerate}
                \item $\forall f~g~x \ldotp \term{either} \ap f \ap g \ap (\term{inl} \ap x) \eqbeta f \ap x$
                \item $\forall f~g~y \ldotp \term{either} \ap f \ap g \ap (\term{inr} \ap y) \eqbeta g \ap y$
            \end{enumerate}
        \end{block}
        \pause
        \begin{block}{Конструкторы}
            \begin{itemize}
                \item Принимают один аргумент
                \item Принимают два действия, из которых выполняют нужное на аргументе
                \item $\term{inl} \ap x \termdef \lambda f~g \ldotp f \ap x$
                \item $\term{inr} \ap y \termdef \lambda f~g \ldotp g \ap y$
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Элиминатор}
            \begin{itemize}
                \item Просто передаёт функции значению для обработки содержимого
                \item $\term{either} \ap f \ap g \ap v \termdef v \ap f \ap g$
            \end{itemize}
        \end{block}
    \end{frame}

    \subsectionplan{Списки}

    \begin{frame}{\subsecname}
        Иногда требуется хранить много сущностей одновременно, и при этом:
        \begin{itemize}
            \item Уметь добавить в коллекцию новую сущность
            \item Найти сущность в коллекции по индексу
        \end{itemize}
        \vspace{0.5em}
        \begin{center}
            \includegraphics[width=0.5\textwidth]{figs/list}
        \end{center}
    \end{frame}

    \begin{frame}[fragile]{Моделируем список}
        \pause
        \begin{block}{API списков}
            \begin{itemize}
                \item $\term{nil}$ --- пустой список
                \item $\term{cons} \ap x \ap t$ --- список из элемента $x$ в голове и списка-хвоста $t$
                \item[\eg] $\tlist{\term{1}, \term{2}, \term{3}} \eqt \term{cons} \ap \term{1} \ap (\term{cons} \ap \term{2} \ap (\term{cons} \ap \term{3} \ap \term{nil}))$
                \item Элиминатор, аккумулирующий элементы: $\term{fold}$
                \item[\eg] $\term{fold} \ap \tlist{\term{1}, \term{2}, \term{3}} \ap f \ap ini \eqbeta f \ap \term{1} \ap (f \ap \term{2} \ap (f \ap \term{3} \ap ini))$
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Законы списков}
            \begin{enumerate}
                \item $\forall f~ini\ldotp \term{fold} \ap \term{nil} \ap f \ap ini \eqbeta ini$
                \item $\forall x~t~f~ini\ldotp \term{fold} \ap (\term{cons} \ap x \ap t) \ap f \ap ini \eqbeta f \ap x \ap (\term{fold} \ap t \ap f \ap ini)$
            \end{enumerate}
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Списки на вариантах}
        \begin{block}{Законы списков}
            \begin{enumerate}
                \item $\forall f~ini\ldotp \term{fold} \ap \term{nil} \ap f \ap ini \eqbeta ini$
                \item $\forall x~t~f~ini\ldotp \term{fold} \ap (\term{cons} \ap x \ap t) \ap f \ap ini \eqbeta f \ap x \ap (\term{fold} \ap t \ap f \ap ini)$
            \end{enumerate}
        \end{block}
        \pause
        \begin{block}{Конструкторы}
            \begin{itemize}
                \item Вершина либо пустая, либо пара из элемента и хвоста
                \item $\term{nil} \termdef \term{inl} \ap \term{0}\footnote{Произвольный терм, чтобы удовлетворить интерфейсу вариантов.}$
                \item $\term{cons} \ap x \ap t \termdef \term{inr} \ap (\term{pair} \ap x \ap t)$
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Элиминатор}
            \[
                \begin{array}{l}
                    \term{fold} \ap xs \ap f \ap ini \termdef \term{either} \ap (\term{K} \ap ini) \ap (\lambda (\term{pair} \ap x \ap t)\ldotp f \ap x \ap (\term{fold} \ap t \ap f \ap ini)) \ap xs
                \end{array}
            \]
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Списки Чёрча}
        \begin{block}{Законы списков}
            \begin{enumerate}
                \item $\forall f~ini\ldotp \term{fold} \ap \term{nil} \ap f \ap ini \eqbeta ini$
                \item $\forall x~t~f~ini\ldotp \term{fold} \ap (\term{cons} \ap x \ap t) \ap f \ap ini \eqbeta f \ap x \ap (\term{fold} \ap t \ap f \ap ini)$
            \end{enumerate}
        \end{block}
        \pause
        \begin{block}{Конструкторы}
            \begin{itemize}
                \item По аналогии с числами Чёрча $\term{k} = \lambda s~z\ldotp \underbrace{s~(s~(\cdots (s~(}_{\textstyle k} z\underbrace{)\cdots ))}_{\textstyle k}$
                \item $\term{nil} \termdef \lambda s~z \ldotp z$
                \item $\term{cons} \ap x \ap t \termdef \lambda s~z\ldotp s~x~(t~s~z)$
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Элиминатор}
            \begin{itemize}
                \item $\term{fold} \ap xs \ap f \ap ini \termdef xs \ap f \ap ini$
                \item $\term{fold} \eqeta \term{id}$
            \end{itemize}
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Задачки про списки Чёрча}
        \[\tlist{M_0, M_1, \cdots, M_{k-1}} \termdef \lambda s~z\ldotp \underbrace{s~M_0~(s~M_1~(\cdots (s~M_{k-1}~(}_{\textstyle k} z\underbrace{)\cdots ))}_{\textstyle k}\]
        \begin{itemize}
            \item[\todo] Напишите проверку на пустоту списка
            \item[\todo] Напишите конкатенацию списков
            \item[\todo] Напишите взятие головы списка
            \item[\answer] \pause
            \begin{columns}[onlytextwidth]
                \begin{column}{0.485\textwidth}
                    \[\term{isZero} \ap n \termdef n~(\lambda z'\ldotp \term{false})~\term{true}\]
                    \vspace{-1.5em}
                \end{column}\hfill\pause%
                \begin{column}{0.485\textwidth}
                    \[\term{isEmpty} \ap l \termdef \pause l~(\lambda x~z'\ldotp \term{false})~\term{true}\]
                    \vspace{-1.5em}
                \end{column}
            \end{columns}
            \item[\answer] \pause $\term{plus} \ap n \ap m \termdef \lambda s~z\ldotp n~s~(m~s~z)$
            \item[\answer] \pause
            \begin{columns}[onlytextwidth]
                \begin{column}{0.485\textwidth}
                    \[\begin{array}{l l}
                          \term{headOrDefault}~\textbf{nil}~d        & \eqt d \\
                          \term{headOrDefault}~(\textbf{cons}~x~t)~d & \eqt x
                    \end{array}\]
                    \vspace{-1.5em}
                \end{column}\hfill\pause%
                \begin{column}{0.485\textwidth}
                    \[\term{headOrDefault} \ap xs \termdef xs \ap \mathbf{K}  \text{ или } \textbf{fst}\]
                    \vspace{-1.5em}
                \end{column}
            \end{columns}
        \end{itemize}
    \end{frame}


    \sectionplan{Энергичность и ленивость}

    \begin{frame}[fragile]{Условное выражение как функция}
        Возьмём какой-нибудь привычный язык программирования.
        Эквивалентен ли код?
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}

                    if b:
                        return f()
                    else:
                        return g()
                \end{minted}
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}
                    def myif(cond, t, e):
                        if cond:
                            return t
                        else:
                            return e
                    myif(b, f(), g())
                \end{minted}
            \end{column}
        \end{columns}
        \pause
        Нет, например:
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}
                    def fac(n):
                        if n <= 1:
                            return 1
                        else:
                            return n * fac(n - 1)
                \end{minted}
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}
                    def fac(n):
                        return myif(n <= 1,
                            1,
                            n * fac(n - 1)
                        )
                \end{minted}
            \end{column}
        \end{columns}
        \vspace{1em}
        Что произойдёт? \pause Вычисление разойдётся.
        \begin{minted}{python}
            fac(3) -> myif(n <= 1, 1, n * fac(n - 1)) #\pause#
                   -> myif(n <= 1, 1, n * myif(n - 1 <= 1, 1, (n - 1) * fac(n - 1 - 1))...
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Энергичная и ленивая семантики вычисления}
%        \pause
%        \vspace{-0.7em}
%        \begin{block}{Подстановочная модель вызова}
%            Вызов функции означает подстановку текста её тела в место вызова.
%        \end{block}
        \begin{block}{Энергичная семантика вычислений}
            Аргументы функции вычисляются до её вызова (подстановки).
        \end{block}
        \begin{block}{Ленивая семантика вычислений}
            Сначала происходит вызов функции, аргументы без необходимости не вычисляются.
        \end{block}
        От энергичной семантики можно перейти к ленивой, как? \pause Лямбды!
        \pause
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}
                    def fac(n):
                        return myif(n <= 1,
                            lambda: 1,
                            lambda: n * fac(n - 1)
                        )
                \end{minted}
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}
                    def myif(cond, t, e):
                        if cond:
                            return t()
                        else:
                            return e()
                \end{minted}
            \end{column}
        \end{columns}
    \end{frame}


    \sectionplan{Материалы \popslide}

    \appendix

    \begin{frame}[fragile]{Списки в Си}
        \begin{minted}{C}
            struct Node {
                int value;
                Node * tail;
            };

            Node * nil = NULL;

            Node * cons(int value, Node * tail) {
                return new Node { value, tail };
            }
        \end{minted}
    \end{frame}

    \begin{frame}{Что посмотреть в транспорте}
        \begin{itemize}
            \item \href{https://habr.com/ru/articles/486548/}{\color{blue} Статья: Примитивно-рекурсивные функции и функция Аккермана}
        \end{itemize}
    \end{frame}

    \begin{frame}{Серьёзные материалы}
        \begin{itemize}
            \item \href{http://www.cs.ru.nl/barendregt60/essays/klop/art16_klop.pdf}{\color{blue} Klop, J. W. ``New fixed point combinators from old.'' Reflections on Type Theory, $\lambda$-Calculus, and the Mind. Essays dedicated to Henk Barendregt on the occasion of his 60th birthday, Radboud University Nijmegen (2007): 197--211.197--211}
        \end{itemize}
    \end{frame}

\end{document}
