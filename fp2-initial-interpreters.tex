%! suppress = MissingLabel

Итак, мы определили, что интерпретаторы --- это основа основ, потому что главная задача программиста --- борьба со сложностью, а главный инструмент этой борьбы --- использование подходящих доменно-специфичных языков, позволяющих думать только о важном, абстрагируя несущественные детали.

В течение этого курса мы будем учиться писать интерпретаторы.
В этом разделе --- классические, которые принимают деревья на вход и интерпретируют их в семантический домен.
Такие интерпретаторы задают deep eDSL (\ref{subsec:edsl}).
Далее мы научимся миновать этап построения дерева определяемого языка, полностью переиспользовать и напрямую расширять мета-язык новыми конструкциями (раздел~\ref{sec:wonder-interpreters}).
Классические интерпретаторы полезны как для реализации ``последнего языка'' --- интерфейса программы во внешний мир, и как фундамент для наших дальнейших построений (см., например, далее~\ref{subsec:to-wonderland}, ~\ref{sec:datatype-generic}).
Также, со временем мы изучим разные подходы к конструированию священного Граалю этой науки~--- расширяемых интерпретаторов~\ref{sec:effect-handlers}.

``Классические'' интерпретаторы часто называют \vocab{инициальными интерпретаторами}.
Слово ``инициальный'' тут относится к тому, что мы имеем дело с инициальным объектом категории интерпретаций.
Всё что нам нужно понимать, --- что инициальные интерпретаторы работают с деревом программы, заданным классически с помощью \mintinline{haskell}|data| (да, деревья можно задавать и по-другому).

Есть отличная книга~\cite{nystrom2021crafting}, рассказывающая о построении классических интерпретаторов и простых виртуальных машин.
В то же время она покрывает сознание полноценного языка во всех его аспектах, от синтаксического анализа до управления памятью.

\subsection{Типы значений}

Рассмотрим, какие есть способы реализации языков, значения в которых могут иметь различные типы.

\subsubsection{Untyped tagless interpreters}

Для начала рассмотрим некоторый тривиальный нетипизироватный язык.
Под нетипизированностью понимаем отсутствие проверки типов как до исполнения программы, так и во время.
Абстрактный синтаксис этого языка зададим следующим образом:
\begin{minted}{haskell}
    data Expr = Const Int | IsZero Expr | If Expr Expr Expr
\end{minted}

Значения, возникающие во время исполнения программ на этом языке будем представлять значениями типов \mintinline{haskell}|Bool| и \mintinline{haskell}|Int| языка Haskell.
Соответственно, семантическим доменом программы на этом языке является либо \mintinline{haskell}|Bool|, либо \mintinline{haskell}|Int|, в зависимости от самой программы.
\begin{minted}{haskell}
    evalUnsafe :: Expr -> forall res . res
    evalUnsafe = \case
      Const val -> unsafeCoerce val
      IsZero cond -> unsafeCoerce $ evalUnsafe @Int cond == 0
      If c t e -> if evalUnsafe c then evalUnsafe t else evalUnsafe e
\end{minted}

Здесь \texttt{unsafeCoerce} используется, чтобы обмануть статическую систему типов Haskell и просто исполнять программы на нашем нетипизированном языке.
Мы имеем право так делать, поскольку \mintinline{haskell}{Int} и \mintinline{haskell}{Bool} в Haskell имеют одинаковый размер.
Неверное написание программы на этом языке или выбор неправильного домена интерпретации приводят к падению.

\subsubsection{Typed tagged interpreters}

Чтобы добиться некоторой безопасности исполнения, будем приписывать значениям некоторые теги, которые будут доступны во время исполнения.
Заведём следующий алгебраический тип:
\begin{minted}{haskell}
    data RtValue = RtBool Bool | RtInt Int
\end{minted}

Теперь семантическим доменов у нас будет тип \mintinline{haskell}|RtValue|, а интерпретатор сможет проверять типы во время исполнения:
\begin{minted}{haskell}
    evalRt :: Expr -> RtValue
    evalRt (IsZero expr) = case evalRt expr of
      RtBool value -> error "Type error"
      RtInt value -> RtBool (value == 0)
    -- ...
\end{minted}

Ситуация с безопасностью программы определённо стала лучше, однако проверка типов во время исполнения~--- это уже поздно: требует дополнительных расходов производительности и удорожает тестирование.

Этот подход часто называют \vocab{динамической типизацей}, когда мы атрибутируем значения некоторой типовой информацией для использования во время исполнения.

\subsubsection{Typed tagless interpreters} \label{subsubsec:typed-tagless-initial}

Опишем систему типов нашего маленького языка.
%! suppress = EscapeAmpersand
\begin{equation*}{}
    \infer[Const]{Const~n : int}{n : Int}
    \quad
    \infer[IsZero]{IsZero~n : bool}{n : int}
    \quad
    \infer[If]{If~c~t~e : \tau}{c : bool & t : \tau & e : \tau}
\end{equation*}
Можем в качестве типовых тегов переиспользовать типы Haskell: \[int \rightsquigarrow Int, bool \rightsquigarrow Bool\]

Заметим, что с помощью обобщённого алгебраического типа данных \mintinline{haskell}|Expr ty| (\ref{subsubsec:gadts}), мы как раз закодировали эти правила вывода.
Иначе говоря, мы получили статически типизированный язык программирования, переиспользовав систему типов Haskell.
\begin{minted}{haskell}
    data Expr ty where
      Const :: Int -> Expr Int
      IsZero :: Expr Int -> Expr Bool
      If :: forall ty . Expr Bool -> Expr ty -> Expr ty -> Expr ty
\end{minted}

Благодаря статической типизации, мы можем отказаться от тегирования значений во время интерпретации.

\subsection{Связывания и функции первого класса} \label{subsec:first-class-functions}

В этом параграфе мы рассмотрим техники и понятия, относящиеся к реализации функций первого класса и связываний в общем.
Эти понятия оказываются крайне полезны, как мы увидим далее.

\mintinline{haskell}|let|-связывания можно представить через функции первого класса следующим образом:
\[
    \term{let} \ap x \termdef N \ap \term{in} \ap M \equiv (\lambda x\ldotp M) \ap N
\]

Напомним, что от функций первого класса можно избавиться с помощью дефункционализации, рассмотренной ранее~\ref{subsubsec:defunctionalization}.

\subsubsection{Связывание имён}

Существует несколько способов задания семантики идентификаторам.

\vocab{Динамическое связывание (dynamic scoping)} --- значение свободных переменных функции зависит от области видимости в месте вызова.
То есть разрешение имени происходит в момент обращения к переменной.
Например, следующий код напечатает \texttt{42}:
\begin{minted}{scala}
    val f = () => {
        val x = 4
        () => x + 1
    }
    val x = 41
    println(f())
\end{minted}

Этот подход проще в реализации и использовался в ранних версиях Lisp'ов, например.
Однако в таком случае функции не являются надежным барьером абстракции, по-хорошему все свободные переменные должны являться частью сигнатуры (вернёмся в этому в~\ref{sec:effect-systems}).

\vocab{Лексическое/статическое связывание (lexical/static scoping)} --- переменные связываются со значениями в момент объявления функции, в момент вызова результат зависит только от параметров (по модулю изменяемого состояния\footnote{Например, в Kotlin в лямбды можно захватывать изменяемые переменные. Изменения снаружи наблюдаемы внутри лямбды, и наоборот. Иногда это может быть очень удобно, однако нередко приводит к очень неочевидному поведению.}).
Слово ``лексический'' часто употребляется в языках, когда мы что-то можем понять из исходного кода без запуска программы.
Так, код из примера выше напечатает 5.

Далее в этом разделе мы будем говорить о различных способах реализации функций первого класса со статическим связыванием переменных, которых, на самом деле, великое множество\footnote{\url{https://jesper.cx/posts/1001-syntax-representations.html}}.

\subsubsection{Подстановки} \label{subsubsec:substitutions}

Как можно заметить, в классическом лямбда-исчислении подстановки от бета-редукции (вспоминали в разделе~\ref{subsec:terms-reduction}) обеспечивают статическое связывание.
Действительно, аргумент немедленно подставляется во все вхождения переменной, соответственно она не остаётся свободной, а просто исчезает.
\[
    (\lambda x\ldotp (\lambda x\ldotp \lambda y\ldotp x + y) \ap 4) \ap 41 \rightsquigarrow (\lambda x\ldotp (\lambda y\ldotp 4 + y)) \ap 41
\]

Такой подход не является самым эффективным, потому что на каждую аппликацию требуется переписывать код функции целиком (!).
В то же время его довольно просто реализовать для некоторых представлений лямбда-термов.
Рассмотрим пример такого представления --- \vocab{locally nameless}~\cite{chargueraud2012locally}.

\begin{minted}{haskell}
    data Term var
      = Var var
      | App (Term var) (Term var)
      | Lam (Term (Maybe var))
\end{minted}

В этом представлении можно выбирать любой тип для именования свободных переменных:
\begin{minted}{haskell}
    example :: Term String
    example = Var "x" `App` Var "y" -- x y
\end{minted}
Добавление каждой связанной переменной добавляет типу переменных нового обитателя \mintinline{haskell}|Nothing| для обращения к ближайшей связанной переменной:
\begin{minted}{haskell}
    -- ?$\lambda x\ldotp x \ap y$?
    example1 = Lam $ Nothing `App` Just "y"
    -- ?$\lambda x \ap y\ldotp x \ap y \ap z$?
    example2 = Lam $ Lam $ Just Nothing `App` Nothing `App` Just (Just "z")
\end{minted}

Удивительно (нет), но монадический bind является реализацией подстановки для таких термов:

\begin{minted}{haskell}
    instance Monad Term where
      (>>=) :: Term var -> (var -> Term var') -> Term var'
      Var var >>= subst = subst var
      App l r >>= subst = App (l >>= subst) (r >>= subst)
      Lam t >>= subst = Lam $ t >>= \case
        Nothing  -> Var Nothing
        Just var -> Just <$> subst var
\end{minted}

\begin{task}
    Подумайте, зачем нужен \texttt{fmap Just} в последней строчке.
\end{task}

Соответственно, call-by-name интерпретатор такого лямбда-исчисления будет выглядеть следующим образом:\footnote{Поскольку мы рассматриваем классическое $\lambda$-исчисление, в качестве результирующего значения мы получаем тоже терм, но в нормальной форме.}

\begin{minted}{haskell}
    eval :: Term var -> Term var
    eval = \case
      Var var -> Var var
      App f arg -> case eval f of
        Lam body -> eval $ body >>= maybe arg Var
        t -> App t (eval arg)
      Lam t -> Lam (eval t)
\end{minted}

Можно заметить, что эта реализация не самая эффективная, потому что мы делаем каждое применение функции лишним проходом по терму.

\subsubsection{Окружение}

Можно делать подстановку значений переменных лениво, распространяя окружение, которое ставит в соответствие свободным переменным термы.
Лучше, в целом, пока не стало, но мы получили композиционную семантику из некомпозиционной путём эксплицирования контекстных зависимостей (подробнее далее~\ref{subsubsec:recover-compositionality}).

\begin{minted}{haskell}
    data Term1 = Var1 String | App1 Term1 Term1 | Lam1 String Term1
    type Env = Map String Term1

    eval1 :: Term1 -> Env -> Term1
    eval1 term env = case term of
      Var1 name -> Map.findWithDefault (Var1 name) name env
      App1 f arg -> case eval1 f env of
        Lam1 name body -> eval1 body (Map.insert name arg env)
        t -> App1 t (eval1 arg env)
      Lam1 name body ->
        let env' = Map.delete name env in
        Lam1 name (eval1 body env')
\end{minted}

\begin{task}
    Объясните, зачем окружение модифицируется на строчке~10?
\end{task}

Если ветка \mintinline{haskell}|Lam1| не будет рекурсивно обходить подтерм и подставлять значения переменных, информация о значениях свободных переменных в нём потеряется и мы получим динамическое связывание вместо статического.
Чтобы восстановить статическое связывание, ветка \mintinline{haskell}|Lam1| интерпретатора должна конструировать замыкание, включающее текущее окружение (см.\ далее~\ref{subsubsec:closures}).

\subsubsection{Замыкания} \label{subsubsec:closures}

Чтобы не делать энергично подстановку в тела функций и сохранить при этом статическое связывание, добавим ещё одну конструкцию, \vocab{замыкание (closure)}\footnote{\url{https://en.wikipedia.org/wiki/Closure_(computer_programming)}}\footnote{Термин closure был предложен Piter Landin, вместе с кучей других вещей.}~\cite[глава 11]{nystrom2021crafting}.
Оно будет хранить контекст, в котором должен исполняться соответствующий терм.

\begin{minted}{haskell}
    data Term1 = Var1 String | App1 Term1 Term1 | Lam1 String Term1
               | Closure Env String Term1 -- только для вычислений
    type Env = Map String Term1

    eval1 :: Term1 -> Env -> Term1
    eval1 term env = case term of
      Var1 name -> Map.findWithDefault (Var1 name) name env
      App1 f arg -> case eval1 f env of
        Closure env' body -> eval1 body (Map.insert name arg $ env <> env')
        t -> App1 t (eval1 arg env)
      Lam1 name body -> Closure env name body
\end{minted}

Замыкания обычно и используют в промышленных языках как представление времени исполнения функций высших порядков.
Во время компиляции сначала производят \vocab{closure conversion}~--- функции высших порядков представляют как пару из окружения и указателя на функцию, принимающую окружение дополнительным аргументом.
Теперь, когда функция не содержит свободных переменных, делают \vocab{lambda lifting}\footnote{\url{https://en.wikipedia.org/wiki/Lambda_lifting}}~--- поднимают её на верхний уровень.
Подробные примеры можно посмотреть в гарвардских слайдах~\cite{closures-slides}.

\subsubsection{Типизированный контекст} \label{subsubsec:typed-env}

Рассмотрим кодирование, описанное, например, в~\cite{kiselyov2012typed}.

Для начала научимся с помощью системы типов Haskell проверять валидность обращения к окружению.
Представим окружение как список типов, закодированный с помощью вложенных пар:
\begin{minted}{haskell}
    (4, (4.0, "hello")) :: (Int, (Double, String))
\end{minted}

Обращение к окружению будем кодировать числом в унарной записи.
Тип числа (типизированной ссылки внутрь контекста) пусть задаёт множество окружений, из которых на такой позиции можно извлечь нужный тип.
\begin{minted}{haskell}
    data Ref env ty where
      Here :: Ref (ty, env) ty
      There :: Ref env ty -> Ref (ty', env) ty
\end{minted}
Например, тип числа 1 утверждает, что с его помощью можно извлечь значение типа \texttt{ty} из контекста, в котором значение соответствующего типа находится на первой позиции (нумерация с нуля):
\begin{minted}{haskell}
    There Here :: Ref (ty', (ty, env)) ty
\end{minted}

Теперь мы можем закодировать типизированное безопасное обращение к контексту:
\begin{minted}{haskell}
    envLookup :: env -> Ref env ty -> ty
    envLookup env ref = case (ref, env) of
      (Here, (x, _)) -> x
      (There ref', (_, env')) -> envLookup env' ref'
\end{minted}

\begin{task}
    Можно ли разобрать пару сразу на строчке 2?
    Поясните.
\end{task}

\subsubsection{Meta-circular интерпретация} \label{subsubsec:meta-circular-initial}

Крайне не хотелось бы для eDSL самостоятельно реализовывать связывания и функции первого класса.
Построим meta-circular интерпретатор (см.~\ref{subsec:edsl}), который будет переиспользовать функции первого класса мета-языка для реализации их в определяемом языке.

Термы теперь будут не только аннотированы результирующими типами, но и типами необходимых для интерпретации окружений, рассмотренных ранее~\ref{subsubsec:typed-env}.
Абстрагированному терму доступно большее окружение.

\begin{minted}{haskell}
    data Term2 env ty where
      Var2 :: Ref env ty -> Term2 env ty
      App2 :: Term2 env (arg -> res) -> Term2 env arg -> Term2 env res
      Lam2 :: Term2 (arg, env) res -> Term2 env (arg -> res)
\end{minted}

Теперь абстракцию можем проинтерпретировать в функцию Haskell, а аппликацию --- в аппликацию:
\begin{minted}{haskell}
    eval2 :: Term2 env ty -> env -> ty
    eval2 term env = case term of
      Var2 ref -> env `envLookup` ref
      App2 f arg -> (eval2 f env) (eval2 arg env)
      Lam2 t -> \arg -> eval2 t (arg, env)
\end{minted}

\begin{task}
    Как так получилось, что в последней строчке нужно принять ещё один аргумент?
\end{task}

\begin{task}
    Это call-by-value интерпретатор или call-by-name?
    От чего это зависит?
\end{task}

\begin{task}
    Подумайте, какое решение должно быть более производительно, это или предыдущее?
\end{task}

Обратите внимание, что теперь функции определяемого языка во время исполнения --- это просто функции мета-языка.
А значит, в программах на определяемом языке мы можем полностью переиспользовать мета-язык!
Добавим для этого конструкцию, позволяющую сохранить произвольное значение мета-языка в дереве:
\begin{minted}{haskell}
    data Term2 env ty where
      Val2 :: ty -> Term2 env ty
      -- ...

    eval2 :: Term2 env ty -> env -> ty
    eval2 term env = case term of
      Val2 x -> x
      -- ...

    example :: Term2 env (Int -> Int)
    example = Lam (Val2 (+) `App2` Val2 1 `App2` Var2 Here)
\end{minted}

\subsubsection{Синтаксис высшего порядка} \label{subsubsec:h-syntax}

Ещё чем мы ещё занимаемся вручную --- определяем связыватели (да ещё и в унарной записи).
Хотим переиспользовать языковые идентификаторы.
Для это мы будем прямо в дереве синтаксиса хранить функции мета-языка~--- использовать \vocab{синтаксис высшего порядка (higher order abstract syntax)}\footnote{\url{https://en.wikipedia.org/wiki/Higher-order_abstract_syntax}}\footnote{\href{https://cstheory.stackexchange.com/questions/20071/what-is-higher-order-in-higher-order-abstract-syntax}{What is higher-order in higher-order abstract syntax?}}~\cite{pfenning1988higher}.

Теперь мы ссылаемся не на переменные, а на значения, нода абстракции содержит честную функцию:
\begin{minted}{haskell}
    data Term3 ty where
      Val3 :: ty -> Term3 ty
      Plus :: Term3 Int -> Term3 Int -> Term3 Int
      App3 :: Term3 (arg -> res) -> Term3 arg -> Term3 res
      Lam3 :: (Term3 arg -> Term3 res) -> Term3 (arg -> res)

    example3 :: Term3 Int
    example3 = (Lam3 \x -> x `Plus` Val3 41) `App3` Val3 1
\end{minted}

Интерпретация очень простая и абсолютно meta-circular:
\begin{minted}{haskell}
    eval3 :: Term3 ty -> ty
    eval3 term = case term of
      Val3 x -> x
      Plus l r -> eval3 l + eval3 r
      App3 f arg -> (eval3 f) (eval3 arg)
      Lam3 f -> \arg -> eval3 (f (Val3 arg))
\end{minted}

\begin{task}
    Можно ли было объявить \mintinline{haskell}|Lam3| следующим образом?
    \begin{minted}{haskell}
        Lam3 :: (arg -> Term3 res) -> Term3 (arg -> res)
    \end{minted}
\end{task}

\subsubsection{Сериализация}

В этом разделе мы говорили о возможных реализациях функций первого класса, то есть функций, которые можно использовать так же гибко, как и данные.
Возникает закономерный вопрос: можем ли мы сериализовать функцию первого класса и послать исполняться на другую машину?

Функция состоит из кода и захваченных свободных переменных в случае статического связывания.
Соответственно, если код представлен в сериализуемом виде (например, позиционно-независимый байт-код), то его в принципе можно переслать по сети и исполнить на другом инстансе виртуальной машины.
Так, например, делает Erlang.
Однако, такой подход неэффективный, так как байт-код нужно интерпретировать или предварительно компилировать.
Таким образом, Erlang жертвует скоростью исполнения ради горизонтальной масштабируемости.

Если мы гарантируем, что на различных узлах кластера исполняется один и тот же код, как обычно и бывает на практике, можно добиться более эффективной реализации.
Например, используя дефункционализацию~(см.~\ref{subsubsec:defunctionalization}), мы можем сериализовать только объекты алгебраического типа, кодирующие функции.
Поскольку на другом узле кластера исполняется такой же код, мы там можем десериализовать объект и исполнить его с помощью \texttt{apply}.
Однако этот подход не очень поддерживает модульность (сложно один алгебраический тип разбить на много, вернёмся к этой задаче в разделе~\ref{subsec:functor-coprod}), а так же \texttt{apply} каждый раз производит декодирование перед исполнением кода (чем, в прочем, можно пренебречь, учитывая работу с сетью).

Подход, реализованный в Haskell\footnote{\url{https://blog.ocharles.org.uk/blog/guest-posts/2014-12-23-static-pointers.html}}\footnote{\url{https://hackage.haskell.org/package/distributed-closure}} позволяет наделить каждую функцию без свободных переменных некоторым статически известным адресом, одинаковым для всех инстансов приложения.
Далее можно сконструировать сериализуемое замыкание путём последовательности частичных применений:
\begin{minted}{haskell}
    data Closure a where
      StaticPtr :: StaticPtr b -> Closure b
      Encoded :: ByteString -> Closure ByteString
      Ap :: Closure (b -> c) -> Closure b -> Closure c

    main = send "some-node" $
      closure (static factorial) `closureAp` closurePure 10
\end{minted}

Подробнее можно прочитать в основополагающей статье про облачный Haskell~\cite{epstein2011towards}.
С практической точки зрения --- в книжке~\cite[глава 16]{marlow2011parallel}.

\begin{task}
    Нужно ли явно добавлять в замыкание свободную переменную \texttt{(*)} (оператор умножения) в реализации факториала?
\end{task}

\subsection{Expression problem: неподвижная точка копроизведения функторов} \label{subsec:functor-coprod}

Рассмотрим первое в этом курсе решение expression problem~\ref{subsec:expression-problem}.

Воспользуемся представлением данных как неподвижной точки функтора (см.~\ref{subsubsec:functor-fixpoint}).
В качестве модельного языка возьмём язык выражений со сложением:
\begin{minted}{haskell}
    data Basic rec = Const Int | Plus rec rec

    algBasic :: Basic Int -> Int
    algBasic = \case Const x -> c; Plus l r -> l + r

    evalBasic :: Fix Basic -> Int
    evalBasic = cata algBasic
\end{minted}

Заметим, что сумма (копроизведение) функторов формы даёт функтор формы, алгебра для которого получается из алгебр компонент\footnote{Пользуемся расширением \href{https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/type_operators.html}{TypeOperators}.}:
\begin{minted}{haskell}
    data (l :+: r) rec = L (l rec) | R (r rec)

    (\/) :: (l a -> a) -> (r a -> a) -> ((l :+: r) a -> a)
    phi \/ psi = \case L l -> phi l; R r -> psi r
\end{minted}

Расширим наш язык чтением числа из окружения.
Следуя рассмотренной ранее денотационной семантике~\ref{subsec:semantics}, выберем функцию \mintinline{haskell}{Int -> Int} в качестве домена:
\begin{minted}{haskell}
    data Basic rec = Const Int | Plus rec rec
    data Input rec = Input

    algBasic' :: Basic (Int -> Int) -> Int -> Int
    algBasic' = \case Const x -> const x; Plus l r -> const (l + r)

    algInput :: Input (Int -> Int) -> Int -> Int
    algInput = \case Input -> \env -> env
\end{minted}

Таким образом, мы добились возможности отдельно определять куски синтаксиса и семантики языка, и собирать нужный язык по месту.
Напишем программу на нашем языке с неявным иммутабельным состоянием:
\begin{minted}{haskell}
    f :: Int -> Int
    f = cata (algBasic' \/ algInput) $
      In (L (Plus (In (L (Const 1))) (In (R Input)))) -- 1 + input
\end{minted}

Однако заметим, что пока мы не решили проблему полностью, так как интерпретация новой конструкции \mintinline{haskell}{Input} потребовала более сложный домен и нам пришлось переписывать интерпретацию старой для него: из \mintinline{haskell}{algBasic} в \mintinline{haskell}{algBasic'}.
Теперь мы понимаем, почему stable denotations~--- это ещё одно название для expression problem~\ref{subsec:expression-problem}.
Далее мы дополним это решение до полноценного~\ref{sec:effect-handlers}.

Полученный терм на встроенном языке пока имеет несколько чудовищную запись, но далее мы рассмотрим, как сделать термы встроенных языков неотличимыми от обычного кода мета-языка.
