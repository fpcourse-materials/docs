%! suppress = MissingImport
%! suppress = MissingLabel
%! suppress = LineBreak

% CLI args https://tex.stackexchange.com/a/1501
\newif\ifhandout
\input{flags}

\input{preamble-slides}

\title[3. Типы в $\lambda$-исчислении]{Практика 3. Типы в $\lambda$-исчислении}
\date{осень 2025}

\begin{document}

    \mymaketitle

    \begin{frame}{В предыдущих сериях}
        \begin{itemize}
            \item Синтаксис и семантика $\lambda$-исчисления
            \item Программирование на $\lambda$-исчислении!
            \item[\newtopic] Синтаксис типов и термов $\lambda_\to$
            \item[\newtopic] Правила типизации $\lambda_\to$
            \item[\newtopic] Гарантии системы $\lambda_\to$
        \end{itemize}
    \end{frame}

    \begin{frame}[noframenumbering]{Содержание}
        \tableofcontents
    \end{frame}


    \sectionplan{Идея систем типов}

    \begin{frame}{Мотивация статического анализа программ}
        \begin{itemize}
            \item Программное обеспечение — это сложно
            \item В программах случаются ошибки (постоянно и неизбежно)
            \item Поиск ошибок может занимать годы, десятилетия, вечность
            \item Нужны методы для того, чтобы судить о программах и их
            свойствах автоматически
            \item Программы могут работать долго
            \item Хотим отвергать ``плохие'' программы до исполнения (статически)
        \end{itemize}
    \end{frame}

    \begin{frame}{Анализ типов}
        \vspace{-0.5em}
        \begin{block}{Идея анализа типов}
            \begin{itemize}
                \item Попытаемся приписать каждой ноде программы синтаксические метки по определённым правилам
                \item Если метки таким образом приписать можно --- программа ``хорошая''
                \item Вид таких меток и правил задаётся \textit{системой типов}
                \item Анализ типов --- разновидность статического анализа
            \end{itemize}
        \end{block}
        \vspace{-3em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.15\textwidth}
                \begin{center}
                    \begin{tikzpicture}
                        \node [decl] (f) {$f : int \to int$};
                        \node [expr] (lam) [below=of f] {$\lambda : int \to int$};
                        \node [decl] (y) [below right = of lam] {$y {\color{red}~: int}$};
                        \node [expr] (div) [below=of lam] {$\div : int$};
                        \node [expr] (x) [below left=of div] {$x : int$};
                        \node [expr] (plus) [below right = of div] {$+ : int$};
                        \node [expr] (param) [below left=of plus] {$y : int$};
                        \node [expr] (two) [below right = of plus] {$2 : int$};
                        \draw[->] (lam) -- (f);
                        \draw[->] (div) -- (lam);
                        \draw[->] (plus) -- (div);
                        \draw[->] (x) -- (div);
                        \draw[->] (two) -- (plus);
                        \draw[->] (param) -- (plus);
                        \draw[->] (y) -- (lam);
                    \end{tikzpicture}
                \end{center}
            \end{column}\hfill%
            \begin{column}[t]{0.62\textwidth}
                \begin{center}
                    \begin{tikzpicture}
                        \node [expr] (app) {$@ : int$};
                        \node [expr] (f) [below left =of app] {$f : int \to int$};
                        \node [expr] (mult) [below right= of app] {$\div : int$};
                        \node [expr] (ten) [below left= of mult] {$10 : int$};
                        \node [expr] (four) [below right= of mult] {$4 : int$};
                        \draw[->] (mult) -- (app);
                        \draw[->] (f) -- (app);
                        \draw[->] (ten) -- (mult);
                        \draw[->] (four) -- (mult);
                    \end{tikzpicture}
                \end{center}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Роль типов в языках}
        \begin{itemize}
            \item Позволяют выявлять некоторые классы ошибок:
            \begin{minted}{haskell}
                GHCi> length 42         -- Ошибка: на вход не список, а число
                GHCi> foldr (+) "ABCDE" -- Ошибка: плюс работает на числах, но не символах
            \end{minted}
            \item Механизм абстракции: интерфейс, скрывающий детали реализации
            \item Средство документирования: как использовать сущность
            \item \textit{Частичная} спецификация поведения
            \item Позволяют генерировать более эффективный низкоуровневый код
        \end{itemize}
    \end{frame}

    \begin{frame}{Ограниченность систем типов \popslide}
        \begin{itemize}
            \item Хотелось бы, чтобы все ``хорошие'' программы типизировались, а все ``плохие'' ~--- нет
            \item Однако по теореме Успенского-Райса задача проверки любого нетривиального\footnote{Существуют программы, как обладающие таким свойством, так и не обладающие.} свойства программы неразрешима
        \end{itemize}
        \vspace{1em}
        В чем подвох с системами типов? \pause
        \begin{itemize}
            \item Всё, что типизируется, --- ``хорошее'', но обратное не всегда верно
            \item[$\Rightarrow$] Всегда существуют ``хорошие'' программы, которые не типизируются\footnote{На приктике к тому же зачастую существуют ``плохие'', которые типизируются.}
        \end{itemize}
        \begin{center}
            \includegraphics[height=0.25\textheight]{figs/types}
        \end{center}
    \end{frame}

    \begin{frame}{При чём тут ФП? \popslide}
        \begin{itemize}
            \item Парадигме агрессивного абстрагирования требуются гибкие системы типов
            \item ФП языки минималистичные и регулярные --- с ними проще работать
        \end{itemize}
        \begin{center}
            \includegraphics[height=0.6\textheight]{figs/cube}
        \end{center}
    \end{frame}


    \sectionplan{$\lambda_\to$ интуитивно}

    \begin{frame}[fragile]{$\lambda_\to$ типизация интуитивно (1)}
        \begin{itemize}
            \item[\todo] Припишите тип терму $\lambda x^{\alpha}\ldotp x$
            \item[\answer] \pause
            \begin{itemize}
                \item Терм задаёт функцию --- тип стрелочный: $\alpha \to ~?$
                \item Типизируем тело, зная $\{x : \alpha\}$: $\lambda x^\alpha\ldotp \underbrace{x}$
                \item Тип результата функции --- $\alpha$ (уже знаем тип $x$)
                \item Значит, тип всей функции $\alpha \to \alpha$
            \end{itemize}
            \item[\todo] Протипизируйте $f \ap x$, зная, что $\{x : \alpha, f : \alpha\to\beta\}$
            \item[\answer] \pause
            \begin{itemize}
                \item Тип $x$ совпадает с ожидаемым типом аргумента
                \item Тип применения $f \ap x$ --- тип результата функции $\beta$
            \end{itemize}
            \item[\todo] Припишите тип терму $\lambda x^\alpha~f^{\alpha \to \beta}\ldotp f \ap x$
            \item[\answer] \pause
            \begin{itemize}
                \item Видим абстракцию --- пишем стрелку $\alpha \to ~?$
                \item Типизируем тело, зная $\{x : \alpha\}$: $\lambda x^\alpha \ldotp \underbrace{\lambda f^{\alpha \to \beta}\ldotp f \ap x}$
                \item Тип тела --- тоже функция: $\alpha \to ((\alpha \to \beta) \to ~?)$
                \item Типизируем тело вложенной функции, зная $\{x : \alpha, f : \alpha \to \beta\}$: $\lambda x^\alpha \ldotp \lambda f^{\alpha \to \beta}\ldotp \underbrace{f \ap x}$
                \item Уже решали, итоговый тип: $\alpha \to ((\alpha \to \beta) \to \beta)$
                \item По ассоциативности стрелки можно убрать одни скобки: $\alpha \to (\alpha \to \beta) \to \beta$
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{$\lambda_\to$ типизация интуитивно (2)}
        \begin{itemize}
            \item[\todo] Припишите тип терму $\lambda x~y\ldotp x$
            \item[\answer] \pause
            \begin{itemize}
                \item Типы аргументов на записаны в терме --- выбираем их самостоятельно
                \item Тело терма никак типы аргументов не ограничивает (нет аппликаций)
                \item Выбираем различные буквы: $\alpha \to \beta \to ~?$
                \item Тип результата совпадает с типом первого аргумента
                \item Ответ: $\alpha\to\beta\to\alpha$
            \end{itemize}
            \item[\todo] Припишите тип терму $\lambda x~y~f\ldotp f \ap x \ap y$
            \item[\answer] \pause
            \begin{itemize}
                \item $f$ в теле принимает два аргумента
                \item Типы $x$ и $y$ никак не ограничены
                \item $\alpha\to\beta\to(\alpha\to\beta\to~?)\to~?$
                \item Тип результата функции ничем не ограничен --- берём свежую букву
                \item Ответ: $\alpha\to\beta\to(\alpha\to\beta\to\gamma)\to\gamma$
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{$\lambda_\to$ население типов интуитивно}
        \begin{itemize}
            \item[\todo] Населите тип $(\beta\to\gamma)\to(\alpha\to\beta)\to\alpha\to\gamma$
            \item[\answer] \pause
            \begin{itemize}
                \item Вспоминаем про ассоциативность стрелки: $(\beta\to\gamma)\to((\alpha\to\beta)\to\alpha\to\gamma)$
                \item Это явно функция, пишем абстрактор: $\lambda f^{\beta\to\gamma}\ldotp \underbrace{\_}_{(\alpha\to\beta)\to\alpha\to\gamma}$
                \item Аналогично ещё две стрелки дают два аргумента: $\lambda f^{\beta\to\gamma}\ap g^{\alpha\to\beta} \ap x^\alpha\ldotp \underbrace{\_}_\gamma$
                \item Единственный способ получить значение типа $\gamma$ --- вызвать $f$:\\
                $\lambda f^{\beta\to\gamma}\ap g^{\alpha\to\beta} \ap x^\alpha\ldotp f \ap \underbrace{\_}_\beta$
                \item Конструируем подходящий аргумент для $f$ типа $\beta$ вызовом $g$:\\
                $\lambda f^{\beta\to\gamma}\ap g^{\alpha\to\beta} \ap x^\alpha\ldotp f \ap (g \ap \underbrace{\_}_\alpha)$
                \item Воспользуемся $x$, чтобы достроить терм нужного типа:\\
                $\lambda f^{\beta\to\gamma}\ap g^{\alpha\to\beta} \ap x^\alpha\ldotp f \ap (g \ap x)$
            \end{itemize}
        \end{itemize}
    \end{frame}


    \sectionplan{$\lambda_\to$ формально}

    \begin{frame}[fragile]{Контекст типизации}
        \begin{itemize}
            \item В программах используются введённые ранее имена
            \item Для типизации нужно знать типы сущностей, связанных ранее с этими именами
            \item Будем поддерживать доп. структуру данных, которую будем заполнять именами с соответствующими им типами в процессе обхода дерева программы
        \end{itemize}
        \begin{block}{Пример на Си}
            \vspace{-1em}
            \begin{columns}[onlytextwidth]
                \begin{column}{0.485\textwidth}
                    \begin{minted}{c}
                    int dostrange(int a, char i) {
                        // point 0
                        int c = 5;
                        for (int i = 0; i < 15; ++i) {
                            i -= 1; // point 1
                            long r = i;
                            i *= r; // point 2
                        }
                        return a + (int)i * c; // point 3
                    }
                    \end{minted}
                \end{column}\hfill%
                \begin{column}{0.485\textwidth}
                    Контекст типизации в каждой из точек:
                    \begin{enumerate}
                        \setcounter{enumi}{-1}
                        \item $\{a : \mathrm{int},\, i : \mathrm{char}\}$
                        \item \pause $\{a : \mathrm{int},\, c : \mathrm{int},\, i : \mathrm{int}\}$
                        \item \pause $\{a : \mathrm{int},\, c : \mathrm{int},\, i : \mathrm{int},\, r : \mathrm{long}\}$
                        \item \pause $\{a : \mathrm{int},\, c : \mathrm{int},\, i : \mathrm{char}\}$
                        \item[$+$] \pause Глобальные определения: \pause \texttt{<}, \texttt{+}, \texttt{*}\ldots
                    \end{enumerate}
                \end{column}
            \end{columns}
        \end{block}
    \end{frame}

    \begin{frame}{Контекст типизации: пример на лямбда-исчислении}
        В чистом лямбда-исчислении имена вводятся с помощью абстракции.
        \begin{columns}[onlytextwidth]
            \begin{column}{0.485\textwidth}
                \begin{center}
                    \begin{tikzpicture}
                        \node [expr] (lamf) {(0) $\lambda$};
                        \node [decl] (f) [below right=of lamf] {$f {\color{red}~: \tau}$};
                        \node [expr] (lamg) [below  =of lamf] {(1) $\lambda$};
                        \node [decl] (g) [below right= of lamg] {$g {\color{red}~: \sigma}$};
                        \node [expr] (lamx) [below  =of lamg] {(2) $\lambda$};
                        \node [decl] (x) [below right= of lamx] {$x {\color{red}~: \zeta}$};
                        \node [expr] (apf) [below  =of lamx] {$@$};
                        \node [expr] (vf) [below left= of apf] {$f$};
                        \node [expr] (apg) [below right=of apf] {$@$};
                        \node [expr] (vg) [below left= of apg] {$g$};
                        \node [expr] (vx) [below right= of apg] {$x$};
                        \draw[->] (lamg) -- (lamf);
                        \draw[->] (lamx) -- (lamg);
                        \draw[->] (f) -- (lamf);
                        \draw[->] (g) -- (lamg);
                        \draw[->] (x) -- (lamx);
                        \draw[->] (apf) -- (lamx);
                        \draw[->] (apg) -- (apf);
                        \draw[->] (vf) -- (apf);
                        \draw[->] (vg) -- (apg);
                        \draw[->] (vx) -- (apg);
                    \end{tikzpicture}
                \end{center}
            \end{column}\hfill%
            \begin{column}{0.485\textwidth}
                Контекст типизации для каждой вершины:
                \begin{enumerate}
                    \setcounter{enumi}{-1}
                    \item \pause $\emptyset$
                    \item \pause $\{f : \tau\}$
                    \item \pause $\{f : \tau, g : \sigma\}$
                    \item[$*.$] \pause $\{f : \tau, g : \sigma, x : \zeta\}$
                \end{enumerate}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}{Определение STLC / simply typed $\lambda$-calculus / $\lambda_\to$}
        \vspace{-0.5em}
        \pause
        \begin{block}{Синтаксис типов в $\lambda_{\rightarrow}$}
            \begin{description}
                \item[Типовые переменные] \vspace{-1em} $\alpha, \beta, \ldots \in \mathbb{T}$
                \hspace{2em}
                \begin{tikzpicture}
                    \node [expr] (a) {$\alpha$};
                \end{tikzpicture}
                \item[Стрелочные типы] \vspace{-2em} $\sigma, \tau \in \mathbb{T} \Rightarrow (\sigma\rightarrow\tau)\in\mathbb{T}$\footnote{Стрелочка --- правоассоциативный оператор: $\tau \to (\sigma \to \zeta) \eqt \tau \to \sigma \to \zeta$.}
                \hspace{2em}
                \begin{tikzpicture}
                    \node [expr] (arr) {$\to$};
                    \node [subtree] (t) [below left= of arr] {$\sigma$};
                    \node [subtree] (s) [below right= of arr] {$\tau$};
                    \draw[->] (t.north) -- (arr);
                    \draw[->] (s.north) -- (arr);
                \end{tikzpicture}
            \end{description}
        \end{block}
        \pause
        \begin{block}{Утверждение типизации}
            \begin{itemize}
                \item Синтаксис: $\Gamma$ --- контекст, $M \in \Lambda, \sigma \in \mathbb{T}$, то $\Gamma \vdash M : \sigma$ --- утверждение типизации
                \item Синтаксическая категория, увязывающая вместе термы и типы с контекстом
                \item Утверждает, что в контексте $\Gamma$ терм $M$ имеет тип $\sigma$
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
    \end{frame}

    \subsectionplan{Задача проверки типа}

    \begin{frame}{Проверка типа комбинатора $\term{B}$ в $\lambda_\to$}
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
        %! suppress = EscapeAmpersand
        \[\resizebox{0.8\hsize}{!}{
            \infer[\visible<3->{intro\to}]
            {\emptyset \vdash \lambda f~g~x.~f~(g~x) : (\beta \to \gamma) \to (\alpha \to \beta) \to \alpha \to \gamma}
            {\visible<3->{
                \infer[\visible<4->{intro\to}]
                {\{f: \beta \to \gamma\} \vdash \lambda g~x.~f~(g~x) : (\alpha \to \beta) \to \alpha \to \gamma}
                {\visible<4->{
                    \infer[\visible<5->{intro\to}]
                    {\{f : \beta \to \gamma, g : \alpha \to \beta\} \vdash \lambda x.~f~(g~x) : \alpha \to \gamma}
                    {\visible<5->{
                        \infer[\visible<6->{elim\to}]{\{f : \beta \to \gamma, g : \alpha \to \beta, x:  \alpha\} \vdash f~(g~x) : \gamma}
                        {\visible<6->{
                            \infer[\visible<7->{ctx}]{\Gamma \vdash f : \beta \to \gamma}{} &
                            \infer[\visible<8->{elim\to}]{\Gamma \vdash g~x : \beta}{\visible<8->{
                                \infer[\visible<9->{ctx}]{\Gamma \vdash g : \alpha \to \beta}{} &
                                \infer[\visible<10->{ctx}]{\Gamma \vdash x : \alpha}{}
                            }}
                        }}
                    }}
                }}
            }}
        }\]
        \begin{itemize}
            \item \visible<11->{Получилось перевёрнутое синтаксическое дерево терма!}
        \end{itemize}
    \end{frame}

    \begin{frame}[noframenumbering]{Таинственные связи \popslide}
        Дерево вывода типа комбинатора $\term{B}$ или \visible<2->{вывод силлогизма в исчислении высказываний?}
        %! suppress = EscapeAmpersand
        \[\resizebox{0.8\hsize}{!}{
            \infer[intro\to]{\emptyset \vdash \visible<1>{{\color{blue} \lambda f~g~x.~f~(g~x) :~}} (\beta \to \gamma) \to ({ \alpha} \to \beta) \to \alpha \to \gamma}{
                \infer[intro\to]{\{\visible<1>{{\color{blue}f:~}} \beta \to \gamma\} \vdash \visible<1>{{\color{blue} \lambda g~x.~f~(g~x) :~}} ({ \alpha} \to \beta) \to \alpha \to \gamma}{
                    \infer[intro\to]{\{\visible<1>{{\color{blue}f:~}} \beta \to \gamma, \visible<1>{{\color{blue}g:~}} {\alpha} \to \beta\} \vdash \visible<1>{{\color{blue} \lambda x.~f~(g~x) :~}} \alpha \to \gamma }{
                        \infer[MP]{\{\visible<1>{{\color{blue}f:~}} \beta \to \gamma, \visible<1>{{\color{blue}g:~}} {\alpha} \to \beta, \visible<1>{{\color{blue}x:~}}  \alpha\} \vdash \visible<1>{{\color{blue} f~(g~x) :~}} \gamma }{
                            \infer[InCtx]{\Gamma \vdash \visible<1>{{\color{blue} f :~}} \beta \to \gamma}{} &
                            \infer[MP]{\Gamma \vdash \visible<1>{{\color{blue} g~x :~}} \beta}{
                                \infer[InCtx]{\Gamma \vdash \visible<1>{{\color{blue} g :~}} {\alpha} \to \beta}{} &
                                \infer[InCtx]{\color{black} \Gamma \vdash \visible<1>{{\color{blue} x :~}} { \alpha}}{}
                            }}}}
            }
        }\]
    \end{frame}


    \subsectionplan{Задача вывода типа}

    %! suppress = TrimWhitespace
    \newcommand{\btypename}{Вывод типа для комбинатора $\term{B}$ }

    \begin{frame}[t]{\btypename (0)}
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
        \[{\color{red}\emptyset \vdash \lambda f~g~x.~f~(g~x) :~ ?_0}\]
        \vspace{-1em}
        \begin{itemize}
            \item Требуется вывести тип терма
            \item Внешней информации нет, типизируем в пустом контексте
            \item Пока для неизвестного типа используем мета-переменную $?_0$
        \end{itemize}
    \end{frame}

    \begin{frame}[t, noframenumbering]{\btypename (1)}
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
        \[
            \infer[intro\to]{\emptyset \vdash \lambda f~g~x.~f~(g~x) :~ ?_1 \to ?_2}
            {\color{red}\{f :~ ?_1\} \vdash \lambda g~x.~f~(g~x) :~ ?_2}
        \]
        \vspace{-1em}
        \begin{itemize}
            \item Видим абстракцию на верхнем уровне: правило $intro\to$
            \item Правило требует стрелочной структуры типа, запоминаем $?_0 =~ ?_1\to ?_2$
            \item Обогащаем контекст переменной типа аргумента функции
        \end{itemize}
    \end{frame}

    \begin{frame}[t, noframenumbering]{\btypename (2)}
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
        \[
            \infer[intro\to]{\emptyset \vdash \lambda f~g~x.~f~(g~x) : ?_1 \to \color{red} ?_3 \to ?_4}{
                \color{red}\infer[intro\to]{\color{black}\{f :~ ?_1\} \vdash \lambda g~x.~f~(g~x) :~ \color{red}?_3 \to ?_4}{
                        {\{f :~ ?_1, g :~ ?_3\} \vdash \lambda x.~f~(g~x) :~ ?_4 }
                }}
        \]
        \vspace{-1em}
        \begin{itemize}
            \item Снова абстракция на верхнем уровне: $intro\to$
            \item Тип $?_2$ должен иметь стрелочную структуру, запоминаем $?_2 =~ ?_3 \to ?_4$
            \item Обогащаем контекст
        \end{itemize}
    \end{frame}

    \begin{frame}[t, noframenumbering]{\btypename (3)}
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
        \[
            \infer[intro\to]{\emptyset \vdash \lambda f~g~x.~f~(g~x) :~ ?_1 \to ?_3 \to \color{red}?_5 \to ?_6}{
                \infer[intro\to]{\{f:~ ?_1\} \vdash \lambda g~x.~f~(g~x) :~ ?_3 \to \color{red}?_5 \to ?_6}{
                    \color{red}\infer[intro\to]{\color{black}\{f:~ ?_1, g:~ ?_3\} \vdash \lambda x.~f~(g~x) :~ \color{red}?_5 \to ?_6 }{
                            {\{f:~ ?_1, g:~ ?_3, x:~ ?_5\} \vdash f~(g~x) :~ ?_6 }
                    }}}
        \]
        \vspace{-1em}
        \begin{itemize}
            \item Снова абстракция на верхнем уровне: $intro\to$
            \item Запоминаем: $?_4 =~ ?_5 \to ?_6$
            \item Обогащаем контекст
            \item Обозначим для краткости $\Gamma = \{f:~ ?_1, g:~ ?_3, x:~ ?_5\}$
        \end{itemize}
    \end{frame}

    \begin{frame}[t, noframenumbering]{\btypename (4)}
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
        %! suppress = EscapeAmpersand
        \[
            \infer[intro\to]{\emptyset \vdash \lambda f~g~x.~f~(g~x) : ?_1 \to ?_3 \to ?_5 \to ?_6}{
                \infer[intro\to]{\{f: ?_1\} \vdash \lambda g~x.~f~(g~x) : ?_3 \to ?_5 \to ?_6}{
                    \infer[intro\to]{\{f: ?_1, g: ?_3\} \vdash \lambda x.~f~(g~x) : ?_5 \to ?_6 }{
                        \color{red}\infer[elim\to]{\color{black}\{f: ?_1, g: ?_3, x: ?_5\} \vdash f~(g~x) :~ ?_6}{
                            \Gamma \vdash f : ?_7 \to ?_6 &
                            \Gamma \vdash g~x : ?_7
                        }}}}
        \]
        \vspace{-1em}
        \begin{itemize}
            \item Аппликация на верхнем уровне: правило $elim\to$
            \item Тип аргумента неизвестен, заводим мета-переменную $?_7$
            \item Типы аргумента и параметра должны совпадать
            \item Тип результата функции равен типу аппликации
        \end{itemize}
    \end{frame}

    \begin{frame}[t, noframenumbering]{\btypename (5)}
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
        %! suppress = EscapeAmpersand
        \[
            \infer[intro\to]{\emptyset \vdash \lambda f~g~x.~f~(g~x) : {\color{red}(?_7 \to ?_6)} \to ?_3 \to ?_5 \to ?_6}{
                \infer[intro\to]{\{f: {\color{red}?_7 \to ?_6}\} \vdash \lambda g~x.~f~(g~x) : ?_3 \to ?_5 \to ?_6}{
                    \infer[intro\to]{\{f: {\color{red}?_7 \to ?_6}, g: ?_3\} \vdash \lambda x.~f~(g~x) : ?_5 \to ?_6 }{
                        \infer[elim\to]{\{f: {\color{red}?_7 \to ?_6}, g: ?_3, x: ?_5\} \vdash f~(g~x) }{
                            \color{red}
                            \infer[1]{\color{black}\Gamma \vdash f : {\color{red}?_7 \to ?_6}}{} &
                            \Gamma \vdash g~x : ?_7
                        }}}}
        \]
        \vspace{-1em}
        \begin{itemize}
            \item В левой ветке правило типизации $ctx$
            \item Получаем, что $?_1 =~ ?_7 \to ?_6$
        \end{itemize}
    \end{frame}

    \begin{frame}[t, noframenumbering]{\btypename (6)}
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
        %! suppress = EscapeAmpersand
        \[
            \infer[intro\to]{\emptyset \vdash \lambda f~g~x.~f~(g~x) : (?_7 \to ?_6) \to ?_3 \to ?_5 \to ?_6}{
                \infer[intro\to]{\{f: ?_7 \to ?_6\} \vdash \lambda g~x.~f~(g~x) : ?_3 \to ?_5 \to ?_6}{
                    \infer[intro\to]{\{f: ?_7 \to ?_6, g: ?_3\} \vdash \lambda x.~f~(g~x) : ?_5 \to ?_6 }{
                        \infer[elim\to]{\{f: ?_7 \to ?_6, g: ?_3, x: ?_5\} \vdash f~(g~x) }{
                            \infer[ctx]{\Gamma \vdash f : ?_7 \to ?_6}{} &
                            \color{red}\infer[elim\to]{\color{black}\Gamma \vdash g~x : ?_7}{
                                \Gamma \vdash g : ?_8 \to ?_7 &
                                \Gamma \vdash x : ?_8
                            }}}}}
        \]
        \vspace{-1em}
        \begin{itemize}
            \item В правой ветке снова видим аппликацию: $elim\to$
            \item Заводим мета-переменную $?_8$
        \end{itemize}
    \end{frame}

    \begin{frame}[t, noframenumbering]{\btypename (7)}
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
        %! suppress = EscapeAmpersand
        \[
            \infer[intro\to]{\emptyset \vdash \lambda f~g~x.~f~(g~x) : (?_7 \to ?_6) \to ({\color{red} ?_8 \to ?_7}) \to ?_5 \to ?_6}{
                \infer[intro\to]{\{f: ?_7 \to ?_6\} \vdash \lambda g~x.~f~(g~x) : ({\color{red} ?_8 \to ?_7}) \to ?_5 \to ?_6}{
                    \infer[intro\to]{\{f: ?_7 \to ?_6, g: {\color{red} ?_8 \to ?_7}\} \vdash \lambda x.~f~(g~x) : ?_5 \to ?_6 }{
                        \infer[elim\to]{\Gamma \vdash f~(g~x) }{
                            \infer[ctx]{\Gamma \vdash f : ?_7 \to ?_6}{} &
                            \infer[elim\to]{\Gamma \vdash g \ap x : ?_7}{
                                \color{red}\infer[ctx]{\color{black}\Gamma \vdash g : {\color{red} ?_8 \to ?_7}}{} &
                                \Gamma \vdash x : ?_8
                            }}}}}
        \]
        \vspace{-1em}
        \begin{itemize}
            \item В левой ветке первое правило: $ctx$
            \item Получаем $?_3 = ?_8 \to ?_7$
        \end{itemize}
    \end{frame}

    \begin{frame}[t, noframenumbering]{\btypename (8)}
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
        %! suppress = EscapeAmpersand
        \[
            \infer[intro\to]{\emptyset \vdash \lambda f~g~x.~f~(g~x) : (?_7 \to ?_6) \to ({\color{red} ?_5} \to ?_7) \to ?_5 \to ?_6}{
                \infer[intro\to]{\{f: ?_7 \to ?_6\} \vdash \lambda g~x.~f~(g~x) : ({\color{red} ?_5} \to ?_7) \to ?_5 \to ?_6}{
                    \infer[intro\to]{\{f: ?_7 \to ?_6, g: {\color{red}?_5} \to ?_7\} \vdash \lambda x.~f~(g~x) : ?_5 \to ?_6 }{
                        \infer[elim\to]{\{f: ?_7 \to ?_6, g: {\color{red}?_5} \to ?_7, x: ?_5\} \vdash f~(g~x) }{
                            \infer[ctx]{\Gamma \vdash f : ?_7 \to ?_6}{} &
                            \infer[elim\to]{\Gamma \vdash g \ap x : ?_7}{
                                \infer[ctx]{\Gamma \vdash g : {\color{red}?_5} \to ?_7}{} &
                                \color{red} \infer[ctx]{\color{black} \Gamma \vdash x : {\color{red} ?_5}}{}
                            }}}}}
        \]
        \vspace{-1em}
        \begin{itemize}
            \item В правой ветке снова срабатывает первое правило: $ctx$
            \item Получаем $?_8 = ?_5$
            \item[\answer] Заменяем мета-переменные на типовые $(\beta \to \gamma) \to (\alpha \to \beta) \to \alpha \to \gamma$
        \end{itemize}
    \end{frame}


    \subsectionplan{Задача населения типа}

    \begin{frame}{Простые примеры задач населения}
        Найдите все возможные варианты для терма $M$ в каждом из случаев:
        \begin{itemize}
            \item[\todo] $\{x: \beta\} \vdash M: \alpha \to \alpha$
            \item[\todo] $\{x: \beta\} \vdash M: \alpha \to \beta$
            \item[\todo] $\{x: \beta\} \vdash M: \alpha \to \gamma$
            \item[\answer] \pause
            \begin{itemize}
                \item Единственный терм типа $\alpha$ передаётся аргументом
                \item Терм обязан вернуть свой аргумент: $M \eqt \lambda x\ldotp x$
            \end{itemize}
            \item[\answer] \pause
            \begin{itemize}
                \item Единственное значение типа $\beta$ есть в контексте
                \item Обязаны вернуть значение из контекста $M \eqt \lambda y\ldotp x$
            \end{itemize}
            \item[\answer] \pause
            \begin{itemize}
                \item Значение типа $\gamma$ брать неоткуда
                \item Этот тип не населён в данном контексте
            \end{itemize}
        \end{itemize}
    \end{frame}


    \subsectionplan{Стили типизации}

    \begin{frame}{Типизация в стиле Карри vs {\color{red} в стиле Чёрча}}
        \begin{block}{Правила вывода утверждений типизации в $\lambda_{\rightarrow}$}
            \vspace{-1em}
            \begin{center}
                \[
                    \begin{array}{l c r}
                        \infer[ctx]{\Gamma \vdash x: \sigma}{(x: \sigma) \in \Gamma}
                        &
                        \infer[elim\to]{\Gamma \vdash M\;N : \tau}{\Gamma \vdash M : \sigma \to \tau & \Gamma \vdash N : \sigma}
                        &
                        \infer[intro\to]{\Gamma \vdash \lambda x^{\color{red} \sigma}\ldotp M : \sigma \to \tau}{\{x : \sigma\} \cup \Gamma \vdash M : \tau}
                    \end{array}
                \]
            \end{center}
        \end{block}
        \vspace{1em}
        По Чёрчу в термах записываются типы при связанных переменных.
        \begin{itemize}
            \item Количество кода
            \begin{description}
                \item[По Чёрчу] Программисту приходится больше писать
                \item[По Карри] Меньше кода, сложнее задача типовой подсистеме языка
            \end{description}
            \item Количество способов приписать терму тип
            \begin{description}
                \item[По Чёрчу] Либо $0$, либо $1$
                \item[По Карри] Либо $0$, либо $\infty$
            \end{description}
            \item Алгоритм вывода
            \begin{description}
                \item[По Чёрчу] Проще, вся необходимая информация написана в терме
                \item[По Карри] Сложнее, приходится решать систему типовых уравнений
            \end{description}
        \end{itemize}
    \end{frame}


    \sectionplan{Материалы \popslide}

    \appendix

    \begin{frame}{Деревья вывода}
        \begin{itemize}
            \item Теория доказательств математической логики --- доказываем принадлежность утверждения типизации множеству истинных утверждений
            \item Истинное утверждение в теории доказательств --- то, которое можно \emph{синтаксически} вывести по правилам вывода из аксиом
            \item Деревья вывода --- синтаксические, машинно-проверяемые конструкции
            \item Деревья сами по себе не несут смысла, наличие корректного дерева говорит только о возможности его построения
            \item Чтобы деревья имели смысл, для каждой теории доказываются утверждения вида:
            \begin{itemize}
                \item Если существует дерево вывода с корнем X, то верно Y
                \item[e.g.] Если существует $\lambda_\to$ дерево с утверждением про терм $M$ в корне (терм $M$ в таком-то контексте имеет такой-то тип), то этот терм строго нормализуем
            \end{itemize}
            \item Иногда по правилам вывода очевиден алгоритм построения дерева
            \begin{itemize}
                \item В нашем случае (для $\lambda_\to$) это так
                \item В общем случае --- нет (математики оказались бы не нужны)
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Не всё сильно-нормализуемое типизируется \advancedslide}
        Вспомним: всё, что типизируется, ``хорошее'', но обратное не всегда верно. Будем ``хорошим'' считать сильную нормализуемость.

        \vspace{1em}
        $\mathbf{2}~\mathbf{K}$ терм сильно нормализуем и редуцируется так:
        \[\mathbf{2}~\mathbf{K} = \lambda z\ldotp \mathbf{K}~(\mathbf{K}~z) = \lambda z~a~b\ldotp z\]
        Однако протипизировать это не получится.
        \begin{itemize}
            \item Наиболее общий тип $\mathbf{K}$~--- это $\gamma \to \tau \to \gamma$
            \item $\mathbf{2} \termdef \lambda s~z\ldotp s~(s~z)$, наиболее общий тип $\mathbf{2}$~--- это $(\alpha \to \alpha) \to \alpha \to \alpha$
            \item По правилу типизации аппликации, применение $\mathbf{2}$ к $\mathbf{K}$ накладывает на $\gamma, \tau, \alpha$ ограничения $\alpha = \gamma, \alpha = \tau \to \gamma$
        \end{itemize}
        Противоречие.
    \end{frame}

    \begin{frame}{Эквивалентности не сохраняют тип \advancedslide}
        \begin{block}{$\beta$-эквивалентность не сохраняет тип}
            Из лекции известно, что если $M$ редуцируется к $N$ и $\Gamma \vdash M: \tau$,
            то $\Gamma \vdash N: \tau$.

            Неправда, что если $M$ редуцируется к $N$ и $\Gamma \vdash N: \tau$, то
            $\Gamma \vdash M: \tau$.

            Пример: $N = \lambda x\ldotp x$, $N: \alpha \to
            \alpha$; $M = \lambda x\ldotp (\lambda y\ldotp x)~(x~\mathbf{I})$, и
            за одно редуцирование $M$ переходит в $N$, но $M: \alpha \to \alpha$ не
            выполняется: тогда бы подтерм $x~\mathbf{I}$ не типизировался, так как $\alpha$
            не является стрелочным типом.
        \end{block}
        \begin{block}{$\eta$-эквивалентность не сохраняет тип}
            Если $\lambda x\ldotp M~x: \tau$ (где $x$ не является свободным в $M$), то
            $M: \tau$.

            Если $M: \tau$, то не обязательно $\lambda x \ldotp M~x: \tau$.

            Пример:
            $\mathbf{I}: \alpha \to \alpha$, но $\lambda x~y\ldotp x~y: (\beta \to \gamma) \to
            (\beta \to \gamma)$ нельзя приписать тип $\alpha \to \alpha$: тогда бы подтерм
            $x~y$ не типизировался, так как $\alpha$ не является стрелочным типом.
        \end{block}
    \end{frame}

    \begin{frame}{Что посмотреть в транспорте}
        \begin{itemize}
            \item \href{https://youtu.be/f12hIDF0XPc}{\color{blue} Формальная верификация операционных систем}
        \end{itemize}
    \end{frame}

    \begin{frame}{Серьёзные материалы}
        \begin{itemize}
            \item \href{https://www.mccme.ru/dubna/2017/courses/bragilevsky.html}{\color{blue} Соответствие Карри–Ховарда: от матлогики к программированию}
            \item \href{https://www.youtube.com/watch?v=_HYI7zjkrEs&list=PLvPsfYrGz3wuVAGhNf6-i7uafXg56oqM5}{\color{blue} Вывод типов от Хиндли-Милнера до GHC 8.8}
            \item \href{https://youtu.be/o-7zhrUP3ds}{\color{blue} Программирование с зависимыми типами на языке Idris}
            \item \href{https://www.amazon.com/Type-driven-Development-Idris-Edwin-Brady/dp/1617293024}{\color{blue} Edwin Brady ''Type-Driven Development with Idris``}
            \item Pierce, Benjamin C. Types and programming languages. MIT press, 2002.
            \item Пирс Б. Типы в языках программирования. — Лямбда пресс, Добросвет, 2012. — 656 c.
            \item \href{https://thinkingwithtypes.com/}{\color{blue} Sandy Maguire ''Thinking with Types. Type-Level Programming in Haskell``}
            \item Henk Barendregt, Wil Dekkers, and Richard Statman. ``Lambda Calculus with Types''. Cambridge University Press, New York, NY, USA, 2013.
            \item Dunfield, Jana, and Neel Krishnaswami. ``Bidirectional typing.'' \textit{ACM Computing Surveys (CSUR)} 54.5 (2021): 1-38.
        \end{itemize}
    \end{frame}

\end{document}
