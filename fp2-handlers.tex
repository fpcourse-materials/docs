%! suppress = MissingLabel

По-другому посмотрим на интерпретаторы встроенных языков, доведём их до абсолюта.
Чтобы менеджить сложность.

% todo

\subsection{Понятие эффекта}

Начнём разговор про эффекты апофатично, с того, чем они не являются.
\vocab{Чистое вычисления} --- единственный его наблюдаемый результат --- его значение.
\vocab{Чистая функция} --- результат зависит только от значения аргументов и её аппликация --- чистое вычисление. % todo аргументы

% todo obsidian What is a purely functional language?

Программирование чистыми функциями считается хорошей практикой, так как этот стиль обладает большим количеством хороших свойств.
Так, композиция чистых функций --- чистая функция; всё, что нужно для понимания кода, явно написано в этом коде; системы типов хорошо работают, предоставляя чистоту абстракции, документацию и частичную спецификацию\ldots

Всё можно записать в виде чистых вычислений, даже IO~\cite{jones2001tackling}.
Но результат нам не понравится~--- всё приходится делать вручную:
\begin{minted}{haskell}
    getList :: Int -> World -> (World, [Int])
    getList n w | n == 0 = (w, [])
                | otherwise =
      let (w', x) = getInt w in
      let (w'', xs) = getList (n - 1) w' in
      (w'', x : xs)
\end{minted}

Нужно делегировать весь этот bookkeeping сторонней сущности, чтобы она занималась этим за нас, то есть замести неинтересное под ковёр:
\begin{minted}{haskell}
    getList :: Int -> IO [Int]
    getList n | n == 0 = pure []
              | otherwise = do
      x <- getInt
      xs <- getList (n - 1)
      return (x : xs)
\end{minted}

Эту абстрактную сущность мы будем называть \vocab{контекстом исполнения}.
А \vocab{эффектом}~--- взаимодействие с контекстом исполнения. % todo Получаем красивую картинку
Контекст исполнения характеризуется двумя свойствами (противополагающими его чистым вычислениям):
\begin{enumerate}
    \item Взаимодействие с контекстом наблюдаемо.
    Контекст~--- memory manager, мутации наблюдаемы~--- влияют на чтение.
    \item Действие контекста ограничено определённой областью.
    Эксепшены.
    Инверсия зависимостей.
\end{enumerate}

На практике этим контекстом является интерпретатор встроенного языке, а операции с эффектом~--- его конструкции.
Поэтому мы снова возвращаемся к задаче построения модульных интерпретаторов.

\subsection{Хендлеры эффектов}

\begin{minted}{haskell}
    data Request res = Val res | Ask (Int -> Request res)

    newtype Eff res = Eff { runEff :: forall res' . (res -> Request res') -> Request res' }
      deriving Functor

    instance Applicative Eff where
      pure x = Eff \k -> k x
      (<*>) = ap

    instance Monad Eff where
      comp >>= k = Eff \k' -> runEff comp \x -> runEff (k x) k'

    ask :: Eff Int
    ask = Eff \k -> Ask k

    run :: Eff res -> Request res
    run comp = runEff comp Val

    runReader :: Eff res -> Int -> res
    runReader comp env = loop (run comp)
      where
        loop = \case
          Val res -> res
          Ask k -> loop (k env)

    exampleReader :: Int -> Int
    exampleReader = runReader do
      x <- ask
      y <- ask
      pure (x + y)
\end{minted}

\begin{minted}{haskell}
data (e |> es) a = L (e a) | R (es a)
  deriving Functor

-- Codensity (Request es)
newtype Eff es res = Eff { runEff :: forall res'. (res -> Request es res') -> Request es res' }
  deriving Functor

instance Applicative (Eff es) where
  pure x = Eff \k -> k x
  (<*>) = ap

instance Monad (Eff es) where
  Eff comp >>= k = Eff \k' -> comp \x -> runEff (k x) k'

data Request es res = Val res | Msg (es (Request es res))

send
  :: (forall res'. (res -> Request es res') -> es (Request es res'))
  -> Eff es res
send f = Eff \k -> Msg (f k)

run :: Eff es res -> Request es res
run (Eff f) = f Val


newtype Reader e k = Ask (e -> k)
  deriving Functor

ask :: Eff (Reader e |> es) e
ask = send \k -> L $ Ask k

runReader
  :: forall es env res . Functor es
  => Eff (Reader env |> es) res
  -> env -> Eff es res
runReader comp env = loop (run comp)
  where
    loop :: Request (Reader env |> es) res -> Eff es res
    loop = \case
      Val res -> pure res
      Msg (L (Ask k)) -> loop (k env)
      Msg (R unknownReq) -> do
        response <- resend unknownReq
        loop response

    resend
      :: es (Request (Reader env |> es) res)
      -> Eff es (Request (Reader env |> es) res)
    resend unknownReq = send \k -> fmap k unknownReq
\end{minted}

% todo

\subsection{Трансформеры монад}

% todo

\subsection{Алгебраичность эффектов}

% todo





%TODO недетерминизм и matter of perspective\footnote{\url{https://okmij.org/ftp/Computation/having-effect.html}} % todo

% todo https://okmij.org/ftp/Computation/having-effect.html
%
% todo diagrams

% todo remind of tagless final

% todo lift - monad morphism

% todo ContT, lift = (>>=)

%TODO\cite{liang1995monad} % todo

%\subsection{Свободные монады}

% todo Stackless Scala with free monads

% todo free monads, freer monads

% todo iteratee O. Kiselyov. Iteratees. In Proc. of the 11th International Symposium on Functional and Logic Programming, pages 166–181, 2012.

% todo Monads and algebras

% todo monad error is a bullshit

% todo iteratee

% todo https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt

% todo https://www.eff-lang.org/handlers-tutorial.pdf

% todo алгебраические эффекты
% todo связь с delimited continuations
% todo стратегии компиляции, связь с codata
% todo эффекты высших порядков
% todo full vs shallow embeddings
% todo abstracting definitional interpreters & github semantics
% todo fused effects and CPS

% todo функция это тоже способ унести код куда-то, обобщённый алгебраический эффект отличается более тонким контролем над континуэйшеном места вызова

% todo compare open type families & extensible interpreters

% todo Polymorphic Symmetric Multiple Dispatch with Variance

% todo \textit{multimethods}

% todo  custom schedulers

%    Languages with \textit{multimethods}, like Common Lisp’s CLOS, Dylan, and Julia do support adding both new types and operations easily.
%    What they typically sacrifice is either static type checking, or separate compilation.

% todo ZIO, TS Effect

% todo call-by-push value and how it is related to effects

% todo context polymorphism
