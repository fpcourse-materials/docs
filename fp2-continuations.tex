%! suppress = MissingLabel

Продолжения с начала 60х не один раз возникали в литературе в различных формах и разнообразных приложениях~\cite{reynolds1993discoveries, landin1997histories}, пока в 70х Wadsworth не придумал общий термин и единую концепцию --- \vocab{continuation}\footnote{\url{https://en.wikipedia.org/wiki/Continuation}} --- ``the meaning of the rest of the program''.

Начальным толчком к размышлениям стал язык Algol 60, имевший нетривиальный механизм меток и прыжков.
Проблемой была как имплементация семантики, так и её денотационное описание вместе с трансляцией в лямбда-исчисление.
Действительно, как математически описать \texttt{goto}?
В каком домене искать семантику таких программ?
Как написать определяющий интерпретатор, отправляющий программу в этот домен?
Ответом стала возможность сослаться на семантику остатка программы в определённой точке.

Итак, продолжение --- это абстрактная концепция, обозначающая остаток вычисления.
Например, когда мы редуцируем простое арифметическое выражение, вычислитель фокусируется внутрь его, чтобы найти редекс.
Оставшееся выражение с дыркой, в которую нужно будет подставить результат вычисления редекса, является продолжением.

% todo picture

Практически продолжение представляет собой некоторую структуру данных, сохраняющее всё что нужно, чтобы продолжить исполнение программы с определённого места.
Иначе говоря, это некоторый снапшот состояния вычислителя, интерпретатора.

Как правило, продолжения существуют вне пользовательского кода.
Это разработчику системы исполнения языка нужно думать, хранение чего нужно поддержать, чтобы продолжать исполнять программу в каждый момент.
Однако, современные языки предоставляют пользователям множество конструкций, позволяющих управлять продолжениями:

\begin{itemize}
    \item Функция \mintinline{haskell}|exit| выбрасывает продолжение программы целиком;
    \item Конструкция \mintinline{kotlin}|try-catch| позволяет выбросить часть продолжения до места поимки исключения и восстановить доставшееся;
    \item Конструкция \mintinline{kotlin}|return| позволяет восстановить исполнение в месте, где функция была вызвана;
    \item Конструкции \mintinline{kotlin}|break| и \mintinline{kotlin}|continue| восстанавливают продолжение после цикла и до\ldots
\end{itemize}

Говоря ``продолжение'' часто понимают продолжения первого класса.
\vocab{Продолжения первого класса (first-class continuations)} --- продолжения, которые представимы в программе в виде значений.
Учитывая, что продолжение имеет вакантное место ещё не вычисленного подвыражения, продолжения первого класса представляют функциями первого класса.

% todo citations on operators





% todo примеры


% todo continuations and operating systems

% todo origins: yoneda (reason isomorphically), logic

% todo continuations and imperative programming

% todo single-shot/multi-shot

% todo first class coninuations

% todo codensity

% todo problems with continuations: typing and resources

% todo implementing while & break

% todo

% todo control operator, runtime наизнанку

\subsection{Continuation-passing style (CPS)}

Базовым способом получить в программе продолжение первого класса --- написать программу в стиле CPS.
CPS эксплуатирует следующий изоморфизм:
\begin{minted}{haskell}
    to :: a -> (forall r . (a -> r) -> r)
    to x k = k x

    from :: (forall r . (a -> r) -> r) -> a
    from comp = comp id
\end{minted}

Иначе говоря, вместо того, чтобы предоставить значение, можно запросить у вызывающей стороны, как она собирается с этим значением работать, сделать это самостоятельно и вернуть вызывающей стороне.

Корни этого изоморфизма в лемме Йонеды из теории категорий~\cite{hinze2010reason}.
Прикладным же программистам он знаком по технике использования callback'ов.

Например, мы можем переписать факториал в стиле CPS:
\begin{minted}{haskell}
    facCps :: Int -> (forall r . (Int -> r) -> r)
    facCps n k
      | n <= 1 = k 1
      | otherwise = facCps (n - 1) \res -> k (n * res)
\end{minted}

\begin{task}
    Вручную поредуцируйте определение \mintinline{haskell}|facCps| на простом примере.
\end{task}

\begin{task}
    Сколько функция \mintinline{haskell}|facCps| потребляет стековой памяти?
\end{task}

\subsubsection{Монада \texttt{Cont}}

Из-за CPS код потерял привычную структуру, при которой функции напрямую возвращают свои результаты.
При наличии большого количества вызовов трансформированных функций, код становится плохо читаемым.

\begin{minted}{haskell}
    fibCps :: Int -> (forall r . (Int -> r) -> r)
    fibCps n k = if n <= 2 then k 1 else
      fibCps (n - 1) \res1 ->
      fibCps (n - 2) \res2 ->
      k (res1 + res2)
\end{minted}

Однако, можно заметить, что монадическое связывание вторым аргументом тоже принимает продолжение, но ``маленькое'', до конца \mintinline{haskell}|do|-блока.
Таким образом, можно попробовать линеаризовать CPS код с помощью монад.

Заведём \mintinline{haskell}|newtype| обёртку для объявления инстансов:
\begin{minted}{haskell}
    newtype Cont r a = Cont { runCont :: (a -> r) -> r }
\end{minted}

Функтор добавляет пост-процессинг результату перед передачей в продолжение:
\begin{minted}{haskell}
    instance Functor (Cont r) where
      -- fmap :: (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
      fmap f (Cont comp) = Cont \k -> comp (k . f)
\end{minted}

Аппликатив просто передаёт значение продолжению:
\begin{minted}{haskell}
    instance Applicative (Cont r) where
      pure x = Cont \k -> k x
      (<*>) = ap
\end{minted}

Наконец, монада принимает в связывании ``маленькое'' продолжение, композирует его с ``большим'' продолжением, пришедшим снаружи, и передаёт в данное вычисление:
\begin{minted}{haskell}
    instance Monad (Cont r) where
      Cont comp >>= k = Cont \k' -> comp \x -> runCont (k x) k'
\end{minted}

Теперь мы можем писать линейный код, а монадическая машинерия сама конструирует продолжения и подкладывает в предыдущие вычисления:
\begin{minted}{haskell}
    fibCont :: Int -> Cont r Int
    fibCont n = if n <= 2 then pure 1 else do
      res1 <- fibCont (n - 1)
      res2 <- fibCont (n - 2)
      pure (res1 + res2)
\end{minted}

\begin{task}
    Оборвите вычисление, если \texttt{res1} больше \texttt{50}.
\end{task}

\begin{task}
    Оборвите вычисление как только общий результат стал больше 50.
\end{task}

% todo call/cc

% todo

\subsubsection{Дефункционализация продолжений}

\cite{reynolds1972definitional}

% todo

\subsubsection{State machine}

% todo циклы и спиллинг

% todo

\subsection{Delimited continuations}

\cite{dyvbig2007monadic}

% todo

\subsubsection{Основные операторы}

% todo

\subsubsection{Реализация в Haskell}

% todo

% todo delimited via undelimited and mutable cell

















%\subsubsubsection{}

% todo пример на хаскеле с примитивом

% todo connection with zipper

% todo goto не нужен? 　


% todo first-class continuations

%\subsubsection{}






% todo Foundations for Programming and Implementing Effect Handlers

% todo связь с монадами

% todo continuation semantics

% todo tasks from Moskvin's stepic

% todo колбеки это продолженя в монадах

% todo sicp

% todo CPS трансформация интерпретаторов

% todo correspondence to negation in intuitionistic logic?

% todo CPS correspond to double negation in logic reynolds1998definitional

% todo defuctionalized continuations, pepers from gibbons talk

% todo SPJ compiling without continuations

% todo difference lists

% todo The Essence of Cornpiling with Continuations

% todo calculating correct compilers

% todo reference to best refactoring
% todo refrence co calculate correct compilers and stuff

\cite{reynolds1972definitional, reynolds1998definitional, defunctionalization-slides}


% todo transducers, pipelines and internal iteration

% todo Delimited continuations and asynchronous exceptions

% todo Oleg's web cite

% todo tags and prompts
