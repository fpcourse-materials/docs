%! suppress = MissingLabel

Продолжения с начала 60х не один раз возникали в литературе в различных формах и разнообразных приложениях~\cite{reynolds1993discoveries, landin1997histories}, пока в 70х Wadsworth не придумал общий термин и единую концепцию --- \vocab{continuation}\footnote{\url{https://en.wikipedia.org/wiki/Continuation}} --- ``the meaning of the rest of the program''.

Начальным толчком к размышлениям стал язык Algol 60, имевший нетривиальный механизм меток и прыжков.
Проблемой была как имплементация семантики, так и её денотационное описание вместе с трансляцией в лямбда-исчисление.
Действительно, как математически описать \texttt{goto}?
В каком домене искать семантику таких программ?
Как написать определяющий интерпретатор, отправляющий программу в этот домен?
Решением стала возможность сослаться на семантику остатка программы, продолжение, в определённой точке (например, на метке).

О продолжениях всегда должен думать автор языка, ведь вычислителю в каждой точке программы нужно знать, что исполнять дальше.
А как мы уже поняли, любой программист является автором множества языков, приближающих его к решению задачи.
Более того, многие повседневные языковые конструкции явно или неявно непосредственно манипулируют продолжениями.

\subsection{Концепция продолжений}

Рассмотрим семантику выражения с операционной точки зрения, как последовательность шагов переписывания (см.\ \ref{subsubsec:semantics}).
Если внимательно рассмотреть каждый шаг, то мы обнаружим, что он состоит из двух этапов: поиска подвыражения (редекса), в котором можно сделать элементарный шаг вычислений, выполнение этого шага, и так далее\footnote{На самом деле вычислениям с продолжениями учат в начальных классах, когда рассказывают про вычисление выражений ``по действиям''.}.
Во время поиска редекса, выражение разбивается на две части (см.~\ref{fig:basic-continuation}):
\begin{itemize}
    \item Фокус --- подвыражение в котором ищем редекс;
    \item Продолжение --- остаток выражения с ``дыркой'', обозначающий место, куда нужно подставить результат шага вычислений.
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=0.35\textwidth]{figs/cont-expr}
    \caption{Выражение разделяется на фокус (красный) и продолжение (синее), когда в фокусе удалось сделать шаг, они объединяются в новое выражение, для которого процесс повторяется.}
    \label{fig:basic-continuation}
\end{figure}

Как правило, продолжения существуют вне пользовательского кода как состояние интерпретатора, которому нужно помнить, что и как исполнять дальше в каждый момент времени.
Однако, языки предоставляют пользователям множество конструкций, позволяющих управлять продолжениями (см.\ \ref{fig:exit-exceptions}):
\begin{itemize}
    \item Функция \mintinline{kotlin}|exit| выбрасывает продолжение программы целиком;
    \item Конструкция \mintinline{kotlin}|try-catch| позволяет выбросить часть продолжения до места поимки исключения и восстановить оставшееся;
    \item Конструкция \mintinline{kotlin}|return| позволяет восстановить исполнение в месте, где функция была вызвана;
    \item Конструкции \mintinline{kotlin}|break| и \mintinline{kotlin}|continue| восстанавливают продолжение после цикла и до\ldots
\end{itemize}

\begin{figure}
    \centering
    \begin{subfigure}[h]{0.29\linewidth}
        \includegraphics[width=1\textwidth]{figs/cont-exit}
    \end{subfigure}
    \begin{subfigure}[h]{0.7\linewidth}
        \includegraphics[width=1\textwidth]{figs/cont-try-catch}
    \end{subfigure}
    \caption{Конструкция \mintinline{kotlin}|exit| выбрасывает продолжение и программа останавливается, в то время как \mintinline{kotlin}{throw} выбрасывает лишь часть продолжения до ближайшего \mintinline{kotlin}{try-catch}.}
    \label{fig:exit-exceptions}
\end{figure}

\subsubsection{Reduction semantics}

Стиль задания операционной семантики через описание поиска примитивных (``\vocab{головных}'') редексов и их редукций называют \vocab{семантикой редукционных контекстов (reduction semantics)}\footnote{\url{https://en.wikipedia.org/wiki/Operational_semantics}}.
Как обычно, следуя Hutton's Razor, рассмотрим интерпретацию маленького простого язычка с вычитанием (несимметричная операция для проверки реализации):
\begin{minted}{haskell}
    data Expr = Const Int | Diff Expr Expr
\end{minted}

Для начала нам нужно определить синтаксис продолжений, ``выражений с дыркой'', и операцию разбиения выражения на фокус и продолжение:
\begin{minted}{haskell}
    data K
      = Hole         -- дырка ?$\boxempty$?
      | LDiff K Expr -- фокус пошел в правое подвыражение, запомнили левое
      | RDiff Int K  -- посчитали левое, фокус пошел вправо

    split :: Expr -> (Expr, K)
    split e = case e of
      Const _ -> (e, Hole)
      Diff (Const _) (Const _) -> (e, Hole) -- примитивный редекс
      Diff (Const l) r ->                   -- левое подвыражение уже посчитано
        let (focus, k) = split r in         -- ищем редекс в правом
        (focus, RDiff l k)
      Diff l r ->                           -- ничего ещё не посчитано
        let (focus, k) = split l in         -- начинам с поиска редекса слева
        (focus, LDiff k r)

    ghci> split (Diff (Diff (Const 1) (Const 2)) (Const 3)) -- (1 - 2) - 3
    (Diff (Const 1) (Const 2), LDiff Hole (Const 3)) -- (1 - 2, ?$\boxempty$? - 3)
\end{minted}

Шаг примитивной редукции умеет только вычитать числа:
\begin{minted}{haskell}
    headReduction :: Expr -> Expr
    headReduction = \case
      Diff (Const l) (Const r) -> Const (l - r)
      e -> e
\end{minted}

После шага примитивной редукции нам понадобится подставить результат обратно в продолжение, чтобы из ``выражения с дыркой'' получить полноценное выражение, которое можно продолжить редуцировать:
\begin{minted}{haskell}
    plugIn :: Expr -> K -> Expr
    plugIn e k = case k of
      Hole -> e
      LDiff k' r -> Diff (e `plugIn` k') r
      RDiff l k' -> Diff (Const l) (e `plugIn` k')
\end{minted}
Как правило, подстановку терма $t$ в продолжение $E$ обозначают как $E[t]$.

Теперь мы можем определить полноценный шаг:
\begin{minted}{haskell}
    transition :: Expr -> Expr
    transition e =
      let (focus, k) = split e in    -- разбиваем на фокус и контекст
      headReduction focus `plugIn` k -- делаем вычисление в фокусе и подставляем
\end{minted}

Тода операционная семантика это развёртка списка промежуточных выражений:
\begin{minted}{haskell}
    eval :: Expr -> [Expr]
    eval = List.unfoldr \prev ->
      let next = transition prev in
      if prev == next then Nothing else Just (next, next)
\end{minted}

Можно заметить, что \texttt{split} и \texttt{plugIn} однозначно определяется по синтаксису продолжений, а \texttt{transition} и \texttt{eval} одинаковы для произвольного языка.
Поэтому семантику редукционных контекстов обычно задают как синтаксис продолжений, перечень главных редукций и единственное правило вывода --- шаг в контексте:\footnote{$\ominus$ обозначает синтаксический минус (ноду в дереве).}
\[
    \begin{array}{lrl}
        \text{Values}             & v & \Coloneqq \mathbb{Z}                                       \\
        \text{Terms}              & t & \Coloneqq v ~|~ t \ominus t                                \\
        \text{Evaluation context} & E & \Coloneqq \square ~|~ E \ominus t ~|~ \mathbb{Z} \ominus E \\
        \text{(diff)}             &   & v_1 \ominus v_2 \longrightarrow v_1 - v_2                  \\
        \text{step}               &   & \infer{E[t] \longrightarrow E[t']}{t \longrightarrow t'}
    \end{array}
\]

Существует стандартный инструмент PLT Redex\footnote{\url{https://redex.racket-lang.org/}} для описания и тестирования семантики в стиле редукционных контекстов.

\subsubsection{Continuation semantics} \label{subsubsec:continuation-semantics}

Запишем денотационную семантику нашего языка:
\begin{minted}{haskell}
    evalDirect :: Expr -> Int
    evalDirect = \case
      Const n -> n
      Diff l r -> evalDirect l - evalDirect r
\end{minted}

Перепишем денотационную семантику в стиле с явными продолжениями.
Но сначала поработаем с типом \mintinline{haskell}{K} и упростим работу с ним:
\begin{minted}{haskell}
    data K = Hole | LDiff K Expr | RDiff Int K
    -- ?$K = 1 + (K \times Expr) + (Int \times K) = 1 + (Expr + Int) \times K$?
    data Frame = LDiff Expr | RDiff Int
    type K = [Frame]
\end{minted}
Получили представление продолжения как стека фреймов.

Денотационную семантику будем записывать для домена \mintinline{haskell}{K -> Int}.
Такая разновидность денотационной семантики с явным представлением смысла остатка программы (в виде \mintinline{haskell}{K}) иногда называют \vocab{continuation semantics}.
А соответствующий стиль программирования с передачей продолжений --- \vocab{continuation passing style (CPS)}.

В нашем continuation semantics будет выглядеть как пара взаимно-рекурсивных функций:
\begin{minted}{haskell}
    evalK :: Expr -> K -> Int
    evalK e k = case e of
      Const n -> k `appK` n             -- выполняем остаток программы
      Diff l r -> evalK l (LDiff r : k) -- запоминаем дальше вычислить правое

    appK :: K -> Int -> Int
    appK k result = case k of
      [] -> result                                -- дальше делать нечего
      LDiff r : k' -> evalK r (RDiff result : k') -- идем вычислять вправо
      RDiff l' : k' -> k' `appK` (l' - result)    -- продолжаем на результате
\end{minted}

%\begin{figure}
%    \centering
%    \begin{tabular}{|c|c|}
%        \hline
%        Фокус         & Продолжение           \\
%        \hline
%        $(5 - 2) - 1$ & $\boxempty$           \\
%        $5 - 2$       & $\boxempty - 1$       \\
%        $5$           & $(\boxempty - 2) - 1$ \\
%        $2$           & $(5 - \boxempty) - 1$ \\
%        $2$           & $(5 - \boxempty) - 1$ \\
%        \hline
%    \end{tabular}
%\end{figure}

Первая рекурсивная реализация \texttt{evalDirect} не заботилась о продолжениях.
Однако, продолжения --- это неотъемлемая часть процесса вычисления, вычислителю нужно знать, что делать дальше в каждый момент.
На самом деле \texttt{evalDirect} лишь делегирует работу с продолжениями определяемого языка мета-языку, но каким образом?
Заметьте, что полученная в итоге реализация \texttt{evalK} хвостово-рекурсивная, а значит, может быть скомпилирована в цикл, не потребляющий стек вызовов, при этом \mintinline{haskell}{K} это стек.
Таким образом, в первом случае мы делали рекурсивные вызовы и продолжение аллоцировалось на (аппаратном) стеке мета-языка, а во втором случае мы самостоятельно аллоцируем стек в куче.

В случае, если стек мета-языка реализован поверх аппаратного, есть риск ошибки его переполнения.
Чтобы этого избежать, используется техника \vocab{trampolining}, которая как раз состоит в ручной аллокации продолжения в куче~\cite{ganz1999trampolined, bjarnarson2012stackless}.

Подобно тому как тип контекста зиппера можно вычислить как производную алгебраического представления соответствующего типа~\cite{huet1997zipper, mcbride2001derivative, abbott2003derivatives}, так можно вычислить тип продолжения свёртки~\cite{mcbride2008clowns}.

\subsubsection{Продолжения первого класса} \label{subsubsec:first-class-cont}

В примерах выше конструкции языка управляют продолжениями неявно (см. \ref{fig:exit-exceptions}).
Однако, иногда вводят операторы, позволяющие явно оперировать продолжениями.
С их помощью можно реализовать как возможности манипуляции потоком управления вроде генераторов и корутин\footnote{\url{https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style\#Example:_coroutines}}\footnote{\url{https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.coroutines/suspend-coroutine.html}}, так и все остальные эффекты вроде состояния (см.\ далее\ \ref{sec:effect-handlers}).

\vocab{Продолжения первого класса (first-class continuations)} --- продолжения, которые представимы в программе в виде значений.
Учитывая, что продолжение имеет вакантное место ещё не вычисленного подвыражения, продолжения первого класса представляют функциями первого класса.

Чтобы получить в коде продолжение первого класса, нужно либо написать код в CPS, либо воспользоваться встроенным в язык оператором, которых придумано великое множество~\cite[приложение A]{hillerstrom2022foundations}.
Например, $J$, \texttt{escape}~\cite{reynolds1972definitional}, \texttt{call/cc}\ldots

Для примера реализуем в языке операцию \texttt{Cont}, позволяющую захватить текущее продолжение.
Он будет принимать пользовательскую функцию и передавать в неё текущее продолжение от себя и до конца программы:
\[
    E[cont\ap f] \longrightarrow f\ap (\lambda x\ldotp E[x])
\]

Сначала расширим язык лямбда-исчислением:
\begin{minted}{haskell}
    data Expr
      = Const Int | Diff Expr Expr
      | Var String | Lam String Expr | App Expr Expr

    data Frame
      = LDiff Expr | RDiff Value
      | LApp Expr | RApp Value
      | SetEnv Env -- после исполнения замыкания возвращаем текущее окружение
\end{minted}

Реализация интерпретатора довольно прямолинейна.
Единственное, сейчас остаток программы представлен в виде линейного списка, который фактически обходится в цикле последовательно.
Нужно не забыть после исполнения тела функции замыкания восстановить изначальное окружение для исполнения продолжения:\footnote{Для удобства буддем передавать окружение неявным параметром.}
\begin{minted}[escapeinside=##]{haskell}
    evalK :: (?env :: Env) => Expr -> K -> Value
    evalK e k = case e of
      Const n -> k `appK` Number n
      Diff l r -> evalK l (LDiff r : k)
      Var name -> k `appK` (?env ! name)
      Lam name body -> k `appK` Closure name ?env body
      App f arg -> evalK f (LApp arg : k)

    appK :: (?env :: Env) => K -> Value -> Value
    appK k result = case k of
      [] -> result
      LDiff r : k' -> evalK r (RDiff result : k')
      RDiff l' : k' -> k' `appK` Number (unwrapNumber l' - unwrapNumber result)
      LApp arg : k' -> evalK arg (RApp result : k')
      RApp f : k' -> case f of
        Closure name env body ->
          let currEnv = ?env in
          let ?env = Map.insert name result env in
          evalK body (SetEnv currEnv : k')
        K env k'' ->
          let currEnv = ?env in
          let ?env = env in
          (k'' ++ SetEnv currEnv : k') `appK` result
        other -> error $ "Expected callable, got " <> show other
      SetEnv env : k' -> let ?env = env in k' `appK` result
      where
        unwrapNumber = \case
          Number n -> n
          other -> error $ "Expected number, got " <> show other
\end{minted}

Наконец, реализуем оператор \texttt{cont}:
\begin{minted}[escapeinside=##]{haskell}
    data Expr = ... | Cont Expr
    data Frame = ... | ContFrame

    evalK e k = case e of
       ...
       Cont f -> evalK f (ContFrame : k)

    appK k result = case k of
       ...
       ContFrame : k' -> [RApp result] `appK` K ?env k' -- переиспользуем ветку RApp
\end{minted}

Рассмотрим несколько примеров (обозначим \mintinline{haskell}{contLam name body = Cont (Lam name body)}, \mintinline{haskell}{(-.) = Diff}, \mintinline{haskell}{c = Const}, \mintinline{haskell}{v = Var} и \mintinline{haskell}{(@) = App}):
\begin{itemize}
    \item \mintinline{haskell}{c 10 -. contLam "k" (c 1)} --- выбросить продолжение и вернуть 1 ($k = 10 - \boxempty$);
    \item \mintinline{haskell}{c 10 -. contLam "k" (v "k" @ c 1)} --- $\step k\ap 1 \step 10 - 1 \step 9$;
    \item \mintinline{haskell}{c 10 -. contLam "k" (v "k" @ c 1 -. c 2)} --- $\step k \ap 1 - 2 \step 9 - 2 \step 7$;
    \item \mintinline{haskell}{c 10 -. contLam "k" (v "k" @ c 1 -. v "k" @ c 2)} --- $\step k \ap 1 - k \ap 2 \step 9 - 8 \step 1$.
\end{itemize}

\subsection{Функциональные продолжения} \label{subsec:functional-cps}

% todo higher-order CPS

Воспользуемся CPS в контексте shallow embedding, который будет сразу строить значение в домене \mintinline{haskell}{forall r . (a -> r) -> r}, где \mintinline{haskell}{a -> r}~--- функциональное представление продолжения.
Так, мы в коде программы в каждой точке будем иметь доступ к продолжению.

Такой CPS эксплуатирует следующий изоморфизм:
\begin{minted}{haskell}
    to :: a -> (forall r . (a -> r) -> r)
    to x k = k x

    from :: (forall r . (a -> r) -> r) -> a
    from comp = comp id
\end{minted}
Иначе говоря, вместо того, чтобы предоставить значение, можно спросить у вызывающей стороны, как она собирается с этим значением работать, сделать это самостоятельно, и вернуть вызывающей стороне.

Прикладным программистам этот изоморфизм знаком по технике использования callback'ов.
Теоретикам же известно, что он является частным случаем леммы Йонеды~\cite{hinze2010reason}.
Сравните CPS с интансом этой леммы в теории предпорядка (выше мы считали \texttt{a = Unit; b = a}):
\begin{gather*}
    a\to b \iso \forall r\ldotp (b\to r)\to (a\to r) \\
    a \le b \iff \forall r\ldotp (b \le r) \Rightarrow (a \le r)
\end{gather*}

Например, мы можем переписать факториал в CPS.
Заметьте, что код имеет доступ к продолжению первого класса (однако, пока никак нетривиально не использует его).
\begin{minted}{haskell}
    facCps :: Int -> (forall r . (Int -> r) -> r)
    facCps n k
      | n <= 1 = k 1
      | otherwise = facCps (n - 1) \res -> k (n * res)

    facCps 3 id ?$\step$? facCps 2 \res -> id (3 * res)
    ?$\step$? facCps 1 \res -> id (3 * (2 * res)) ?$\step$? id (3 * (2 * 1)) ?$\step$? 6
\end{minted}

\begin{task}
    Сколько функция \mintinline{haskell}|facCps| потребляет стековой памяти?
\end{task}

\subsubsection{Дефункционализация и аккумуляторы} \label{subsubsec:defunctionalization-cont}

Дефункционализируем продолжения в \texttt{facCps}.
Мы используем две функции высших порядков, \texttt{id} и \mintinline{haskell}{\res -> k (n * res)}, они дают нам два конструктора:
\begin{minted}{haskell}
    data K = Id | Times Int K
    -- ?$\iso$?
    type K = [Int]

    evalK :: K -> Int
    evalK = product

    facCps :: Int -> K -> Int
    facCps n k
      | n <= 1 = evalK k
      | otherwise = facCps (n - 1) (snoc k n)

    facCps 3 [] ?$\step$? facCps 2 [3] ?$\step$? facCps 1 [3, 2] ?$\step$? evalK [3, 2] ?$\step$? 3 * (2 * 1)
\end{minted}

Мы снова получили представление продолжения в виде стека фреймов.
А значит, интерпретатор \texttt{evalK} полученный нами ранее (\ref{subsubsec:continuation-semantics}) является CPS версией обычного интерпретатора, только с дефункционализированными продолжениями (они удобны для отладки~--- их можно распечатать, в отличие от функций Haskell).
Если расширить тот наш язык и написать на нём факториал, а потом сделать fusion (рефункционализацию дерева программы), мы получим текущую реализацию факториала. % todo

Теперь заметим, что операция умножения ассоциативна, а значит, можно \texttt{snoc} заменить на умножение, а продолжение представить одним числом.
Получим привычную реализацию факториала с аккумулятором:
\begin{minted}{haskell}
    facAcc :: Int -> Int -> Int
    facAcc n acc
      | n <= 1 = acc
      | otherwise = facAcc (n - 1) (acc * n)

    facAcc 3 1 ?$\step$? facAcc 2 (1 * 3) ?$\step$? facAcc 1 ((1 * 3) * 2) ?$\step$? (1 * 3) * 2 ?$\step$? 6
\end{minted}
Этой техникой можно пользоваться и в более сложных случаях, чтобы получать хвостово-рекурсивные реализации~\cite{gibbons2021continuation}\footnote{\href{https://youtu.be/8gnhaE2nmQ0?si=pEJX4jQteYmy7ZZn}{(youtube) Jeremy Gibbons - Continuation-passing style, defunctionalization, and associativity.}}.
Также, можно фреймы представить в рефункционализированном виде и в качестве ассоциативной операции использовать композицию функций\footnote{\url{https://wiki.haskell.org/Difference_list}}.

% todo можно ли не пользоваться тем, что единица нейтральная

\subsubsection{\mintinline{haskell}{Monad Cont}} \label{subsubsec:monad-cont}

Из-за CPS код потерял привычную структуру, при которой функции напрямую возвращают свои результаты (i.e. \vocab{direct style}).
При наличии большого количества вызовов трансформированных функций, код становится плохо читаемым (проблема известна как \vocab{callback hell}):
\begin{minted}{haskell}
    fibCps :: Int -> (forall r . (Int -> r) -> r)
    fibCps n k = if n <= 2 then k 1 else
      fibCps (n - 1) \res1 ->
      fibCps (n - 2) \res2 ->
      k (res1 + res2)
\end{minted}

Домен \mintinline{haskell}{(a -> r) -> r} можно сделать монадой и восстановить direct style код внутри \mintinline{haskell}{do}-нотации.
Заведём \mintinline{haskell}|newtype| обёртку для объявления инстансов:
\begin{minted}{haskell}
    newtype Cont r a = Cont { runCont :: (a -> r) -> r }
\end{minted}

Функтор добавляет пост-процессинг результату перед передачей в продолжение:
\begin{minted}{haskell}
    instance Functor (Cont r) where
      -- fmap :: (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
      fmap f (Cont comp) = Cont \k -> comp (k . f)
\end{minted}

Аппликатив просто передаёт значение продолжению:
\begin{minted}{haskell}
    instance Applicative (Cont r) where
      pure x = Cont \k -> k x
      (<*>) = ap
\end{minted}

Можно заметить, что монадическое связывание вторым аргументом тоже принимает продолжение, но ``маленькое'', до конца \mintinline{haskell}|do|-блока.
Таким образом, смысл реализации монадического связывания для \mintinline{haskell}{Cont}~--- это композиция ``маленького'' продолжения с ``большим'' продолжением, передаваемым снаружи:
\begin{minted}{haskell}
    instance Monad (Cont r) where
      (>>=) :: Cont r a -> (a -> Cont r b) -> Cont r b
      Cont comp >>= k = Cont \k' -> comp \x -> runCont (k x) k'
\end{minted}

Теперь мы можем писать линейный код, а монадическая машинерия сама конструирует продолжения и подкладывает в предыдущие вычисления:
\begin{minted}{haskell}
    fibCont :: Int -> Cont r Int
    fibCont n = if n <= 2 then pure 1 else do
      res1 <- fibCont (n - 1)
      res2 <- fibCont (n - 2)
      pure (res1 + res2)
\end{minted}

\begin{task}
    Оборвите вычисление, если \texttt{res1} больше \texttt{50}.
\end{task}

\begin{task}
    Оборвите вычисление как только общий результат стал больше 50.
\end{task}

Монада \mintinline{haskell}{Cont} даёт реализацию встроенного языка, в котором можно получить продолжение вычисления:
\begin{minted}{haskell}
    Cont :: ((a -> r) -> r) -> Cont r a
\end{minted}

\subsubsection{\texttt{call/cc}}

Можно получить доступ к продолжению просто написав где-то в \mintinline{haskell}|do|-нотации конструктор:
\begin{minted}{haskell}
    do ...; Cont \?\framebox{k}? -> ...; ...
\end{minted}
Однако, для получения продолжений, как правило, пользуются специальными операторами.
Классическим примером является \texttt{call/cc} (call with current continuation):
\begin{minted}{haskell}
    callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
    callCC f = Cont \k -> runCont (f \x -> Cont \_ -> k x) k
\end{minted}

\texttt{call/cc} принимает функцию \texttt{f}, в которую передаёт текущее продолжение (рис.~\ref{fig:call-cc}).
При этом вызов продолжения работает как \mintinline{kotlin}|return| для \texttt{f} (продолжение не содержит кода \texttt{f}):
\begin{minted}{haskell}
    foo :: Int -> Cont r String
    foo x = callCC $ \k -> do
      let y = x ^ 2 + 3
      when (y > 20) $ k "over twenty"
      pure (show $ y - 4)
\end{minted}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\linewidth]{figs/call-cc}
    \caption{\texttt{call/cc} вызывает функцию \texttt{f} с продолжением \texttt{k}.
    Аргумент \texttt{k} (или результат \texttt{f}) подставляется вместо вхождения \texttt{call/cc}.}
    \label{fig:call-cc}
\end{figure}

Например, с помощью \texttt{call/cc} можно реализовать кооперативную многозадачность\footnote{\href{https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style\#Example:_coroutines}{(wiki) Continuation-passing style.
Example: coroutines.}}.
Однако, считается, что \texttt{call/cc} --- не самый удачный примитив\footnote{\url{https://okmij.org/ftp/continuations/against-callcc.html}}.

\subsubsection{The mother of all monads} \label{subsubsec:monadic-reflection}

\begin{minted}{haskell}
    newtype Cont r a = Cont { runCont :: (a -> r) -> r }

    instance Functor (Cont r) where
      -- fmap :: (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
      fmap f (Cont comp) = Cont \k -> comp (k . f)

    instance Applicative (Cont r) where
      pure x = Cont \k -> k x
      (<*>) = ap

    instance Monad (Cont r) where
      Cont comp >>= k = Cont \k' -> comp \x -> runCont (k x) k'

    fibCont :: Int -> Cont r Int
    fibCont n = if n <= 2 then pure 1 else do
      res1 <- fibCont (n - 1)
      res2 <- fibCont (n - 2)
      pure (res1 + res2)


    runIdentityC :: (forall r . Cont r a) -> a
    runIdentityC comp = runCont comp id

    exampleIdentity :: Int
    exampleIdentity = runIdentityC do
      x <- pure 4
      y <- pure 5
      pure (x + y)


    raise :: Cont (Maybe r) a
    raise = Cont $ const Nothing

    runExn :: (forall r . Cont (Maybe r) a) -> Maybe a
    runExn comp = runCont comp Just

    exampleExn :: Int -> Maybe Int
    exampleExn n = runExn do
      when (n < 0) raise
      pure (n + 1)


    choice :: Cont [r] Bool
    choice = Cont \k -> k True ++ k False ++ k True ++ k False

    runNondet :: (forall r . Cont [r] a) -> [a]
    runNondet comp = runCont comp (:[])

    exampleNondet :: Int -> [Int]
    exampleNondet n = runNondet do
      b <- choice
      if b then pure n else pure (n - 1)


    -- s -> (s, a) ~ ((s, a) -> r) -> (s -> r)
    -- ~ (a -> s -> r) -> (s -> r) ~ Cont (s -> r) a

    get :: Cont (s -> r) s -- (s -> s -> r) -> (s -> r)
    get = Cont \k s -> k s s

    put :: s -> Cont (s -> r) ()
    put s' = Cont \k _s -> k () s'

    runStateK :: (forall r . Cont (s -> r) a) -> s -> (a, s)
    runStateK comp = runCont comp (,)

    exampleState :: Int -> ((), Int)
    exampleState = runStateK do
      s <- get
      put (s + 1)


    reflect' :: Monad m => m a -> forall r . Cont (m r) a
    reflect' comp = Cont (comp >>=) -- k :: a -> m r

    reify' :: Monad m => (forall r . Cont (m r) a) -> m a
    reify' comp = runCont comp pure

    newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
    newtype CodensityT m a = CodensityT
      { runCodensityT :: forall r . (a -> m r) -> m r }
      deriving Functor

    instance Applicative (CodensityT m) where
      pure x = CodensityT \k -> k x
      (<*>) = ap

    instance Monad (CodensityT m) where
      CodensityT comp >>= k = CodensityT \k' ->
        comp \x -> runCodensityT (k x) k'

    exampleCodensity :: Int -> (Int, Int)
    exampleCodensity = runState $ run $ do
      s <- getCod
      putCod (s + 1)
      pure 1
      where
        run :: CodensityT (State Int) Int -> State Int Int
        run cod = (runCodensityT cod) @Int pure

    getCod :: CodensityT (State s) s
    getCod = CodensityT \k -> State \s -> runState (k s) s

    putCod :: s -> CodensityT (State s) ()
    putCod s' = CodensityT \k -> State \_s -> runState (k ()) s'


    class MonadR m where
      -- m a -> (a -> m r) -> m r
      reflect :: m a -> forall r . Cont (m r) a
      -- (forall r . (a -> m r) -> m r) -> m a
      reify :: (forall r . Cont (m r) a) -> m a

    newtype State s a = State { runState :: s -> (a, s) } deriving Functor

    instance Applicative (State s) where
      pure x = State \s -> (x, s)
      (<*>) = undefined

    instance MonadR (State s) where
      reflect :: State s a -> (forall r . Cont (State s r) a)
      reflect comp = Cont \k -> State \s ->
        let (a, s') = runState comp s in
        runState (k a) s'

      reify :: (forall r . Cont (State s r) a) -> State s a
      reify comp = State $ runState (runCont comp (\x -> State (x,)))
\end{minted}

% todo Monads and composable continuations by Phill Wadler

% todo Representing Monads Filinsky
% todo paper delimited continuations in WebAssembly

% todo связь с континуэйшенами

% todo mother of all monads

% todo monads in python with nice syntax

% todo monadic reflection & direct style (lib from scala)
% todo https://github.com/lampepfl/monadic-reflection/blob/main/TUTORIAL.md

% todo reflection without remorse

% todo C# expression trees
% todo F# что-то про монады и forM https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions

% todo https://blog.poisson.chat/posts/2019-10-27-continuation-submonads.htm

% todo https://www.unison-lang.org/docs/fundamentals/abilities/for-monadically-inclined/

% todo https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads

% todo http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html

% todo

\subsubsection{Эффективная реализация продолжений} \label{subsubsec:efficient-cps}

Существует несколько классических подходов реализации продолжений на языковом уровне, которые, как правило, используются для построения генераторов или корутин.

\vocab{Стековая (stackful)} реализация подразумевает, что продолжение представляется в виде аппаратного стека.
Как только требуется захватить продолжение, стек копируется в кучу (возможно, лениво)\footnote{\href{https://youtu.be/kwS3OeoVCno?si=c4MkSkmLHNeywPrZ}{(youtube) Иван Углянский - Java Project Loom.}}.
То есть этот подход полагается на поддержку со стороны рантайма языка.

\vocab{Сегментный стек} --- стек вызовов представляется как связный список аллоцированных в куче фреймов. % todo cite
Так, не требуется делать копирования, достаточно подмены указателей.
Однако, в таком случае стек нелокален, что не очень хорошо для работы кешей.

\vocab{Безстековая (stackless)} реализация подразумевает автоматическую CPS трансформацию пользовательского кода.
Это можно сделать лишь средствами компилятора.

В нашей реализации CPS производится огромное количество аллокаций замыканий, реифицирующих продолжения.
Однако, если CPS получается автоматической трансляцией, можно делать эффективнее.
Изначально продолжения придумывались для описания семантики прыжков, но можно пойти и в обратную сторону, реализовав продолжения эффективно для современных машин через \texttt{goto}.

Так, состояние функции целиком один раз аллоцируется в куче, а перемещения по телу реализованы как машина состояний --- с помощью меток и прыжков.
Таким образом, например, реализованы безстековые корутины в Kotlin\footnote{\url{https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md\#state-machines} \label{note:kotlin-state}}, генераторы в C\#\footnote{\url{https://csharpindepth.com/Articles/IteratorBlockImplementation}}\ldots

Даже в таком виде CPS остаётся тяжеловесной трансформацией, способной замедлить исполнение кода на порядки.
Дело, в частности, в том, что переменные в таком подходе сложно размещать в регистрах (у функций много точек выходов и входов\footref{note:kotlin-state}), приходится постоянно записывать их в RAM --- производить \vocab{spilling}\footnote{\url{https://en.wikipedia.org/wiki/Register_allocation}}.

% todo объяснение через дефункционализацию

% todo плюсы минусы подводные камни каждого из них

% todo картинки

\subsection{Delimited continuations} \label{subsec:delimited-cont}

% todo Monads and composable continuations

Ранее мы рассматривали \vocab{неограниченные (undelimited) продолжения}, которые представляют собой весь остаток программы до её конца.
В том числе, мы рассматривали оператор \texttt{call/cc}, который реифицирует неограниченное продолжение в виде функции для непосредственного использования пользователем.
Однако, предоставление пользователю неограниченных продолжений ведёт к множеству проблем и не очень полезно на практике~\footnote{\url{https://okmij.org/ftp/continuations/against-callcc.html}}.

Более того, неограниченные продолжения де-факто --- не совсем функции, так как они не возвращают результата (он уже ``beyond the grave''), следовательно, они также не композируются (как и странно композировать \texttt{abort} с \texttt{exit})\footnote{\url{https://okmij.org/ftp/continuations/undelimited.html}}.
Неограниченные продолжения --- это скорее ко-значения, пока часть программы выполняется, они ожидают её результата~\cite{curien2000duality}.

Вместо этого вводятся парные операторы для работы с \vocab{ограниченными (delimited) продолжениями}\footnote{\url{https://www.cl.cam.ac.uk/teaching/2324/R277/handout-delimited-continuations.pdf}}\footnote{\href{https://youtu.be/TE48LsgVlIU?si=cBdUCzYwYWpwPkkh}{(youtube)  Keynote: Delimited Continuations, Demystified by Alexis King | Lambda Days 2023}.}. % todo разграниченными/composable/subcontinuations
Один позволяет пользователю ограничить продолжение, второй --- захватить всё продолжение до вхождения первого, ограничивающего, оператора.
Таким образом, всё продолжение нарезается на сегменты, некоторый префикс которых может быть реифицирован.

Например, операция кидания и поимки исключения состоит из конструкции \mintinline{kotlin}|try-catch|, ограничивающей продолжение, и \mintinline{kotlin}|throw|, которая позволяет выкинуть частичное продолжения (не захватывая его):
\[
    E_1[catch\{E_2[throw(v)], f\}] \to E_1[f(v)]
\]

В литературе встречается огромное количество операторов, для работы с ограниченными продолжениями~\cite[приложение А]{hillerstrom2022foundations}.
Мы рассмотрим классификацию из классической работы~\cite{dyvbig2007monadic}.

Работа вводит следующий набор синтаксических конструкций (рис.~\ref{fig:prompt-syntax} и~\ref{fig:dc-operational}) для работы с ограниченными продолжениями в дополнение к чистому call-by-value лямбда-исчислению.
Исторически в лиспах неограниченные продолжения были ограничены лишь REPL, отсюда название ограничений --- ``prompt''.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.75\linewidth]{figs/prompt-syntax}
    \caption{Синтаксис $\lambda$-исчисления с примитивами для работы с продолжениями.}
    \label{fig:prompt-syntax}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{figs/dc-operational}
    \caption{Операционная семантика.}
    \label{fig:dc-operational}
\end{figure}

\begin{itemize}
    \item $newPrompt$ --- создаёт свежий идентификатор (метку) ограничения;
    \item $pushPrompt \ap p \ap e$ --- устанавливает ограничение с меткой $p$ и исполняет выражение $e$;
    \item $withSubCont\ap p\ap f$ --- захватывает частичное продолжение до ограничения с меткой $p$ и передаёт в функцию $f$, возвращает результат $f$ (рис.~\ref{fig:push-prompt});
    \item $pushSubCont\ap k \ap v$ --- исполняет композицию текущего продолжения и $k$ на значении $v$.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\linewidth]{figs/push-prompt}
    \caption{Пример работы \texttt{withSubCont}.}
    \label{fig:push-prompt}
\end{figure}

Операторы ограниченных продолжений легко понять как \vocab{resumable exceptions}, исключения, которые можно поймать, а программу возобновить с того места, где исключение было выброшено (с некоторым значением).
Необычно то, что классические операторы ограниченных продолжений принимают код, работающий с частичным продолжением в месте ``кидания исключения'', а не в месте ``поимки''.
То есть блок обработки пишется не с \mintinline{kotlin}|catch|, а с \mintinline{kotlin}|throw|:

\begin{gather*}
    ч
    E_1[withSubCont \ap p \ap \{E_2[pushSubCont \ap f]\}] \to E_1[f \ap E_2]
    \\
    E_1[catch\{E_2[throw \ap v], f\}] \to E_1[f \ap v \ap (\lambda x\ldotp E_2[x])]
\end{gather*}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{figs/dc-example}
    \caption{Пример выражения (результат --- $9$).}
    \label{fig:dc-example}
\end{figure}

\begin{task}
    Поредуцируйте пример рис.~\ref{fig:dc-example}.
\end{task}

Остальные операторы более-менее выражаются через обсуждённые нами.
Существует классификаций операторов по признакам --- включает ли захватываемое частичное продолжение ограничение и оставляет ли его за собой~\cite{dyvbig2007monadic}.

% todo in haskell native implementation

% todo

\subsection{Приложения продолжений} \label{subsec:cont-applications}

% todo calculating correct compilers, compiling with continuations W. Appel

% todo CEKT
% todo abstract machines

% todo continuation semantics

% todo single-shot/multi-shot

% todo codensity

% todo problems with continuations: typing and resources

% todo implementing while & break

% todo control operator, runtime наизнанку

% todo CPS трансформация интерпретаторов

% todo SPJ compiling without continuations

% todo The Essence of Compiling with Continuations

% todo calculating correct compilers

% todo reference to best refactoring https://www.pathsensitive.com/2019/07/the-best-refactoring-youve-never-heard.html

% todo game semantics from Carl's slides

% todo http://www.serpentine.com/blog/2011/02/25/cps-is-great-cps-is-terrible/

% todo https://www.joachim-breitner.de/blog/778-Don%E2%80%99t_think,_just_defunctionalize

% todo связь с Box f
% todo коиндуктивные домены

% todo rust continuations

% todo runtime кишками наизнанку

% todo продолжение как структура данных поддерживаемая интерпретатором чтобы знать куда идти дальше
% todo продолжения и реальное железо

% todo controlling allocations of continuations

% todo Delimited Continuations in Operating Systems

% todo Revisiting Coroutines
