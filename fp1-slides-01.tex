%! suppress = MissingLabel
%! suppress = LineBreak

% CLI args https://tex.stackexchange.com/a/1501
\newif\ifhandout
\input{flags}

\input{preamble-slides}

\title[Программирование в $\lambda$-исчислении]{Практика 1. Программирование в $\lambda$-исчислении}
\date{осень 2024}

\begin{document}

    \setcounter{framenumber}{-1}
    \maketitle

    \begin{frame}{В предыдущих сериях}
        \begin{itemize}
            \item[\newtopic] Синтаксис лямбда-исчисления
            \item[\newtopic] Свободные и связанные переменные
            \item[\newtopic] Классические комбинаторы
            \item[\newtopic] Бета-редукция
            \item[\newtopic] $\alpha, \beta,\eta$-эквивалентности
        \end{itemize}
    \end{frame}

    \begin{frame}[noframenumbering]{Содержание}
        \tableofcontents
    \end{frame}

    \sectionplan{Метаинформация о курсе}

    \begin{frame}{Отчётность} % TODO
        \begin{itemize}
            \item Оценка за курс --- оценка за экзамен (успеваемость по практике тоже учитывается)
            \item Допуск на экзамен --- зачёт по всем домашкам, кроме, может быть, одной
            \item Правила зачёта по домашкам расписаны в самих домашках
            \item Отчётность будет вестись в гугл-табличке, правила пользования:
            \begin{itemize}
                \item Не сравниваем свою успеваемость с другими и не переживаем
                \item Смотрим, к кому можно обратиться за помощью
                \item Перфекционизм --- зло
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Домашки}
        \begin{itemize}
            \item Выдаются на каждую неделю
            \item В конце семестра будет достаточно возможностей добрать баллов
            \item В начале каждой пары будет разбор
            \item За частичные решения тоже даются баллы
            \item После пары старайтесь как можно скорее начать делать задания
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Коммуникация online}
        \begin{itemize}
            \item Личка преподавателей в телеграме
            \item Общий чат в телеграме\footnote{Все ссылки на wiki.}
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Коммуникация offline}
        \begin{itemize}
            \item Лучше спросить сразу: ``потом'' не будет времени, и сил не прибавится
            \item Спрашивать --- ответственность и работа студентов
            \item Распределять время и оценивать уместность --- ответственность и работа преподавателя
            \item Если совсем трудно, пишите в чат/личку во время пары или подходите после пары
        \end{itemize}
    \end{frame}

    \begin{frame}{Туториал по прохождению}
        \begin{itemize}
            \item Работайте с эмоциями и держитесь рациональных решений
            \item Старайтесь спокойно относиться к неудачам и работать с их причинами
            \begin{itemize}
                \item Тайм-менеджмент
                \item Садитесь за домашки не в последний момент
                \item Старайтесь понять, а не ``натыкать'' задание
            \end{itemize}
            \item Не стесняйтесь просить помощи у преподавателей и одногруппников
            \begin{itemize}
                \item Иногда можно организовывать дополнительную встречу, если с темой у многих проблемы
            \end{itemize}
            \item Повторяйте материал перед парами
            \begin{itemize}
                \item Времени требуется не много, но толку --- куча!
                \item Для практик более-менее достаточно повторить последнюю лекцию
            \end{itemize}
            \item Спите! Иначе всё более-менее без толку
            \item Отдыхайте! Иначе на дистанции вы будете сильно терять в производительности
        \end{itemize}

        \vspace{1em}
        Полезная \href{https://compscicenter.notion.site/compscicenter/b6dddf00bc7d497298179a3bdbdda375}{\color{blue} памятка} от кураторов Computer Science Center.
    \end{frame}

    \begin{frame}{Зачем изучать ФП/теорию языков программирования}
        \vspace{-0.5em}
        \begin{block}{Для самоопределения}
            \begin{itemize}
                \item ФП~--- лакмусовая бумажка: понравился курс $\Rightarrow$ скорее всего понравится профессионально заниматься языками, в науке или промышленности
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Чтобы быть более хорошими программистами}
            \begin{itemize}
                \item Узнать, что вообще в принципе идейно бывает в языках
                \begin{enumerate}
                    \item Проще изучать новые языки
                    \item Придумываем решение в пространстве возможного
                    \item[\then] А потом аппроксимируем в терминах конкретного языка
                \end{enumerate}
                \item Дисциплинирует ум и учит выбирать более лаконичные и композируемые абстракции
                \item Прививает хорошие практики программирования и аккуратное отношение к эффектам
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Чтобы иметь базу для дальшейшего погружения в науку}
            \begin{itemize}
                \item ФП на пересечении многих областей (вычислимость, доказательства, категории\ldots)
                \item ФП --- основа академической традиции теории языков программирования
                \item Proof engineering и машинно-проверяемые доказательства --- всё тут
            \end{itemize}
        \end{block}
    \end{frame}

    \sectionplan{$\lambda$-исчисление}

    \subsection{Синтаксис $\lambda$-исчисления}

    \begin{frame}{Синтаксис лямбда-исчисления}
        Множество программ (термов) --- $\Lambda$, множество допустимых переменных --- $V$.

        Синтаксис задаётся индуктивным определением:
        \begin{description}
            \item[Переменные] $x \in \Lambda$, если $x \in V$ \hspace{2em}
            \begin{tikzpicture}
                \node [expr] (x) {x};
            \end{tikzpicture}
            \pause
            \item[Абстракция] $(\lambda x\ldotp M) \in \Lambda$, если $x \in V, M \in \Lambda$ \hspace{2em}
            \begin{tikzpicture}
                \node [expr] (lam) {$\lambda$};
                \node [decl] (x) [below right = of lam] {$x$};
                \node [subtree] (m) [below = of lam] {$M$};
                \draw[->] (m.north) -- (lam);
                \draw[->] (x) -- (lam);
            \end{tikzpicture}
            \pause
            \item[Аппликация] $(M~N) \in \Lambda$, если $M \in \Lambda, N \in \Lambda$ \hspace{2em}
            \begin{tikzpicture}
                \node [expr] (dog) {$@$};
                \node [subtree] (m) [below left= of lam] {$M$};
                \node [subtree] (n) [below right= of lam] {$N$};
                \draw[->] (m.north) -- (lam);
                \draw[->] (n.north) -- (lam);
            \end{tikzpicture}
        \end{description}
    \end{frame}

    \begin{frame}[fragile]{Пример программы в лямбда-исчислении}
        \begin{columns}[onlytextwidth]
            \begin{column}{0.55\textwidth}
                \[\lambda f \ap g\ldotp \lambda x\ldotp f~(g~x)\]
                \begin{itemize}
                    \item[\todo] Какие скобочки пропущены в этой записи?
                    \item[\todo] Можно ли опустить имеющиеся?
                    \item[\todo] Как выглядит дерево синтаксиса, соответствующее этому терму?
                \end{itemize}
            \end{column}\hfill%
            \pause%
            \begin{column}{0.45\textwidth}
                \begin{center}
                    \begin{tikzpicture}
                        \node [expr] (lamf) {$\lambda$};
                        \node [decl] (f) [below right=of lamf] {$f$};
                        \node [expr] (lamg) [below  =of lamf] {$\lambda$};
                        \node [decl] (g) [below right= of lamg] {$g$};
                        \node [expr] (lamx) [below  =of lamg] {$\lambda$};
                        \node [decl] (x) [below right= of lamx] {$x$};
                        \node [expr] (apf) [below  =of lamx] {$@$};
                        \node [expr] (vf) [below left= of apf] {$f$};
                        \node [expr] (apg) [below right=of apf] {$@$};
                        \node [expr] (vg) [below left= of apg] {$g$};
                        \node [expr] (vx) [below right= of apg] {$x$};
                        \draw[->] (lamg) -- (lamf);
                        \draw[->] (lamx) -- (lamg);
                        \draw[->] (f) -- (lamf);
                        \draw[->] (g) -- (lamg);
                        \draw[->] (x) -- (lamx);
                        \draw[->] (apf) -- (lamx);
                        \draw[->] (apg) -- (apf);
                        \draw[->] (vf) -- (apf);
                        \draw[->] (vg) -- (apg);
                        \draw[->] (vx) -- (apg);
                    \end{tikzpicture}
                \end{center}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Свободные и связанные переменные}
        \begin{columns}[onlytextwidth]
            \begin{column}{0.55\textwidth}
                \[\lambda x\ldotp (\lambda x~y\ldotp x)\ap (x \ap y)\]
                \begin{itemize}
                    \item[\todo] Какие переменные свободные в этом терме?
                    \item[\todo] Какими связывателями связаны остальные?
                \end{itemize}
            \end{column}\hfill%
            \pause%
            \begin{column}{0.45\textwidth}
                \begin{tikzpicture}
                    \node [expr] (lamx) {$\lambda$};
                    \node [decl] (x) [below right= of lamx] {$x$};
                    \draw[->] (x) -- (lamx);
                    \node [expr] (ap) [below= of lamx] {$@$};
                    \draw[->] (ap) -- (lamx);
                    % left
                    \node [expr] (lamxx) [below left= of ap, xshift=-0.5cm] {$\lambda$};
                    \draw[->] (lamxx) -- (ap);
                    \node [decl] (xx) [below right= of lamxx] {$x$};
                    \draw[->] (xx) -- (lamxx);
                    \node [expr] (lamy) [below= of lamxx] {$\lambda$};
                    \draw[->] (lamy) -- (lamxx);
                    \node [decl] (y) [below right= of lamy] {$y$};
                    \draw[->] (y) -- (lamy);
                    \node [expr] (vxx) [below= of lamy] {$x$};
                    \draw[->] (vxx) -- (lamy);
                    % right
                    \node [expr] (apl) [below right=of ap, xshift=0.5cm] {$@$};
                    \draw[->] (apl) -- (ap);
                    \node [expr] (vx) [below left=of apl] {$x$};
                    \node [expr] (vy) [below right=of apl] {$y$};
                    \draw[->] (vx) -- (apl);
                    \draw[->] (vy) -- (apl);
                \end{tikzpicture}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}{Синтаксические договорённости}
        Снизим синтаксическую зашумлённость с помощью следующих договорённостей:
        \pause
        \begin{block}{Договорённость о введении синонимичных имён}
            \[
                \term{B} \termdef \lambda f \ap g\ldotp \lambda x\ldotp f~(g~x)
            \]
            \pause
            Введём специальную $\delta$-редукцию для синтаксической подстановки определений:
            \[
                \term{B} \step_{\delta} \lambda f \ap g\ldotp \lambda x\ldotp f~(g~x)
            \]
        \end{block}
        \pause
        \begin{block}{Договорённость об аргументах: ``комбинаторный'' синтаксис}
            Следующую запись определения будем считать эквивалентной предыдущей:
            \[
                \term{B} \ap f \ap g \termdef \lambda x\ldotp f~(g~x)
            \]
        \end{block}
    \end{frame}

    \subsectionplan{Семантика $\lambda$-исчисления}

    \begin{frame}[fragile]{\subsecname}
        \begin{itemize}
            \item Задаём смысл термов через эквивалентность
            \item Термы ``означают'' одно и то же, если эквивалентны
            \item Смысл терма --- класс эквивалентности, в котором он находится
            \item Класс можно задать ``особенным'' представителем (далее)
        \end{itemize}
    \end{frame}

    \begin{frame}{$\beta$-редукция}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                Находим редекс:
                \begin{center}
                    \begin{tikzpicture}
                        \node [subtree] (top) {$K$};
                        \node [hexpr] (ap) [below = of top] {$@$};
                        \node [hexpr] (lam) [below left = of ap] {$\lambda$};
                        \node [decl] (x) [below right = of lam] {$x$};
                        \node [subtree] (l) [below = of lam] {$M$};
                        \node [subtree] (r) [below right = of ap] {$N$};
                        \draw[->] (ap) -- (top);
                        \draw[->] (lam) -- (ap);
                        \draw[->] (l) -- (lam);
                        \draw[->] (r.north) -- (ap);
                        \draw[->] (x) -- (lam);
                    \end{tikzpicture}
                \end{center}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.485\textwidth}
                Сокращаем редекс:
                \begin{center}
                    \begin{tikzpicture}
                        \node [subtree] (top) {$K$};
                        \node [subtree] (bot) [below = of top] {$\subst{M}{x}{N}$};
                        \draw[->] (bot) -- (top);
                    \end{tikzpicture}
                \end{center}
            \end{column}
        \end{columns}
    \end{frame}

    % todo утащить задания из листочков

    \subsectionplan{Сопутствующие концепции}

    \begin{frame}[fragile]{Каррирование}
        \vspace{-0.5em}
        Эквивалентен ли код?
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \vspace{0.2 em}
                \[\textbf{K}^* \termdef \lambda x~y\ldotp y\]
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}
                    def k_star(x, y):
                        return y
                \end{minted}
            \end{column}
        \end{columns}
        \pause
        Нет:
        \vspace{-2em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \vspace{0.5em}
                \[\comb{K}^* \ap q \step_\delta (\lambda x~y\ldotp y) \ap q \step_\beta \lambda y\ldotp y \]
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}
                    > k_star(q)
                    TypeError: k_star() missing 1 required
                        positional argument: 'y'
                \end{minted}
            \end{column}
        \end{columns}
        \pause
        \vspace{0.3em}
        Правильная трактовка: ``$\comb{K}^*$ --- функция, которая игнорирует свой аргумент и возвращает
        функцию, которая возвращает свой аргумент'':
        \vspace{-1.5em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \vspace{0.5em}
                \[\lambda x~y\ldotp y \equiv \lambda x\ldotp \lambda y\ldotp y\]
            \end{column}\hfill
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}
                    def k_star(x):
                        def helper(y):
                            return y
                        return helper
                \end{minted}
            \end{column}
        \end{columns}
        \pause
        \vspace{-0.5em}
        \begin{block}{Каррирование}
            Преобразование функции многих аргументов в набор вложенных функций, каждая из которых принимает часть аргументов исходной\footnote{В ООП методы класса каррированные --- часть их ``аргументов'' передаётся через конструктор.}.
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Замыкания}
        Что если закодировать не $\comb{K}^*$, а $\comb{K}$:
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \vspace{0.5em}
                \[\comb{K} \termdef \lambda x\ldotp \lambda y\ldotp x\]
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}[escapeinside=??]{python}
                    def k(x):
                        def helper(y):
                            return ?\framebox{x}?
                        return helper
                \end{minted}
            \end{column}
        \end{columns}
        \pause
        \begin{block}{Замыкание (closure)}
            Пара из функции и окружения (состояния, к которому код функции имеет доступ).
        \end{block}
        \pause
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{Ещё пример на Python}
                    \begin{minted}[escapeinside=??]{python}
                        screen = Screen(...)
                        def handler():
                            ?\framebox{screen}?.textField = ""
                        clearButton.onClick(handler)
                    \end{minted}
                \end{block}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{Ещё пример на C++}
                    \begin{minted}[escapeinside=??]{c++}
                        auto screen = new Screen(...);
                        clearButton.onClick([&screen]() {
                            ?\framebox{screen}?.textField = "";
                        });
                    \end{minted}
                \end{block}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Функции высших порядков}
        \begin{block}{Функция высших порядков (high-order functions, HOF)}
            Принимает другие функции в качестве аргументов.
        \end{block}
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{Пример на $\lambda$-исчислении}
                    \[\comb{B} \termdef \lambda \framebox{f} \ldotp \lambda \framebox{g} \ldotp \lambda x\ldotp f~(g~x)\]
                \end{block}
                \pause
                \begin{block}{Пример на Python}
                    На практике не всегда каррирование по всем аргументам оправдано:
                    \begin{minted}[escapeinside=??]{python}
                        def compose(?\framebox{f}?, ?\framebox{g}?):
                            def helper(x):
                                return f(g(x))
                            return helper
                    \end{minted}
                \end{block}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{Пример на C++}
                    \begin{minted}[escapeinside=??]{c++}
                        function<int(int)> compose(
                            ?\framebox{function<int(int)> f}?,
                            ?\framebox{function<int(int)> g}?
                        ) {
                            return [f, g](int x) {
                                return f(g(x))
                            }
                        }
                    \end{minted}
                \end{block}
            \end{column}
        \end{columns}
    \end{frame}


    \sectionplan{Кодирование данных в лямбда-исчислении}

    \subsection{Значения-записи (records, tuples)}

    \begin{frame}[fragile]{\subsecname}
        Одна сущность может описываться несколькими различными свойствами:
        \begin{itemize}
            \item Комментарий в соцсети: автор, пост, текст, количество лайков\ldots
            \item Котик: имя, мурлычность (очевидно)
        \end{itemize}
        \begin{block}{Пример: Python}
            \begin{minted}{python}
                class Cat:
                   def __init__(self, name, murlicity):
                      self.name = name
                      self.murlicity = murlicity
            \end{minted}
        \end{block}
        \begin{block}{Пример: C++}
            \begin{minted}{c}
                struct Cat {
                    string name;
                    int murlicity;
                };
            \end{minted}
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Что мы хотим от структуры данных?}
        \pause
        \vspace{-0.5em}
        \begin{block}{Конструкторы}
            Создают новые значения структуры данных:
            \begin{minted}{python}
                barsik = Cat(name = "barsik", murlicity = 4)
            \end{minted}
        \end{block}
        \pause
        \begin{block}{Элиминаторы (селекторы)}
            Получают информацию из структуры данных:
            \begin{minted}{python}
                barsik.murlicity
            \end{minted}
        \end{block}
        \pause
        \begin{block}{Мутаторы}
            Изменение информации в экземпляре структуры данных:
            \begin{minted}{python}
                barsik.murlicity = barsik.murlicity + 3
            \end{minted}
            \pause
            В ФП не принято пользоваться изменяемыми данными, и мутаторы не нужны\footnote{\href{https://elizarov.medium.com/immutability-we-can-afford-10c0dcb8351d}{\color{blue} Roman Elizarov: Immutability we can afford.}}:
            \begin{minted}{python}
                happyBarsik = Cat(name = barsik.name,
                                  murlicity = barsik.murlicity + 3)
            \end{minted}
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Законы конструкторов и элиминаторов для значений-записей}
        Как убедиться, что конструкторы и элиминаторы работают правильно?
        \pause
        \begin{enumerate}
            \item \mintinline{python}|forall n m. Cat(name = n, murlicity = m).name == n|
            \item \mintinline{python}|forall n m. Cat(name = n, murlicity = m).murlicity == m|
        \end{enumerate}
        \pause
        \vspace{1em}
        Таким образом, в лямбда-исчислении мы хотим \pause термы $\term{cat}$, $\term{name}$ и $\term{murlicity}$:
        \begin{enumerate}
            \item $\forall N~M\ldotp \term{name}~(\term{cat}~N~M) \equiv_\beta N$
            \item $\forall N~M\ldotp \term{murlicity}~(\term{cat}~N~M) \equiv_\beta M$
        \end{enumerate}
        \pause
        \vspace{1em}
        Таким образом, получаем абстракцию по данным:
        \begin{itemize}
            \item Можем выбрать произвольную реализацию, удовлетворяющую законам
            \item Можем забыть, как устроена реализация и разгрузить голову
            \item Можем в произвольный момент подменить реализацию на другую (например, на более эффективную), и пользовательский код не сломается
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Реализация котиков}
        Для реализации можем воспользоваться концепцией \pause замыканий!
        \pause
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.375\textwidth}
                \begin{block}{Котики в языке с числами}
                    \begin{minted}[escapeinside=??]{python}
                        def cat(?\pause?name, murlicity): ?\pause?
                            def dispatch(i): ?\pause?
                                if i == 0: ?\pause?
                                    return name ?\pause?
                                elif i == 1: ?\pause?
                                    return murlicity
                            return dispatch
                        ?\pause?
                        def name(c): ?\pause?
                            return c(0)
                        ?\pause?
                        def murlicity(c):
                            return c(1)
                    \end{minted}
                \end{block}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.595\textwidth}
                \begin{block}{Котики в языке без чисел}
                    \begin{minted}[escapeinside=??]{python}
                        def cat(name, murlicity):
                            def dispatch(?\pause?selector): ?\pause?
                                return selector(name, murlicity) ?\pause?
                            return dispatch
                        ?\pause?
                        def name(c): ?\pause?
                            return c(lambda name, murlicity: name)
                        ?\pause?
                        def murlicity(c):
                            return c(lambda name, murlicity: murlicity)
                    \end{minted}
                \end{block}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}{Котики в лямбда-исчислении}
        \vspace{-0.5em}
        \begin{block}{Закон котиков}
            \begin{enumerate}
                \item $\forall N~M\ldotp \term{name}~(\term{cat}~N~M) \equiv_\beta N$
                \item $\forall N~M\ldotp \term{murlicity}~(\term{cat}~N~M) \equiv_\beta M$
            \end{enumerate}
        \end{block}
        \begin{itemize}
            \item[\todo] Закодируйте котиков в лямбда-исчислении
        \end{itemize}
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{itemize}
                    \item$\term{cat} \termdef \pause \lambda x~y\ldotp \lambda f \ldotp f \ap x \ap y$
                    \item $\term{name} \termdef \pause \lambda c \ldotp c \ap \term{K}$
                    \item $\term{murlicity} \termdef \pause \lambda c \ldotp c \ap \term{K}^*$
                \end{itemize}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.485\textwidth}
                \begin{itemize}
                    \item $\term{pair} \termdef \lambda x~y\ldotp \lambda f \ldotp f \ap x \ap y$
                    \item $\term{fst} \termdef \lambda p \ldotp p \ap \term{K}$
                    \item $\term{snd} \termdef \lambda p \ldotp p \ap \term{K}^*$
                \end{itemize}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Проверка законов пар}
        \begin{itemize}
            \item[\todo] Проверьте, что реализация удовлетворяет законам
            \item[\answer] \pause
            \begin{align*}
                \term{fst} \ap &(\term{pair} \ap \framebox{N} \ap M)
                \step_\delta \pause \\
                \term{fst} \ap &((\lambda x~y\ldotp \lambda f \ldotp f \ap x \ap y) \ap N \ap M)
                \step_\beta \pause \\
                \term{fst} \ap &(\lambda f \ldotp f \ap N \ap M)
                \step_\delta \pause \\
                (\lambda p \ldotp p \ap \term{K}) \ap &(\lambda f \ldotp f \ap N \ap M)
                \step_\beta \pause \\
                &(\lambda f \ldotp f \ap N \ap M) \ap \term{K}
                \step_\beta \pause \\
                &\term{K} \ap N \ap M \step_{\beta} \framebox{N}
            \end{align*}
            \item Теперь можно пользоваться правилом большого шага:
            \begin{equation*}
                \term{fst} \ap (\term{pair} \ap N \ap M) \sstep N
            \end{equation*}
        \end{itemize}
    \end{frame}

    \begin{frame}{Каррирование}
        \begin{itemize}
            \item[\todo] Как выразить функцию многих аргументов?
            \item[\answer] \pause Пусть принимает кортеж аргументов!
            \item[\todo] Реализуйте ``переключение'' между стилями
            \item[\answer] \pause
            \[
                \begin{array}{l l}
                    \term{curry}   & \termdef \lambda f\ldotp \pause \lambda a~b\ldotp \pause f~ \pause (\term{pair}~a~b) \pause \\
                    \term{uncurry} & \termdef \lambda f\ldotp \pause \lambda p\ldotp f~ \pause (\term{fst}~p)~(\term{snd}~p)
                \end{array}
            \]
        \end{itemize}
        \pause
        \begin{block}{Соглашение о распаковке}
            \[
                \begin{array}{l l}
                    \term{curry}~f~a~b                 & \termdef f~(\term{pair}~a~b) \\ \pause
                    \term{uncurry}~f~(\term{pair}~a~b) & \termdef f~a~b
                \end{array}
            \]
        \end{block}
    \end{frame}

    \begin{frame}{}
        \begin{center}
            \vspace{3em}
            \includegraphics[width=0.5\textwidth]{figs/curry}
        \end{center}
    \end{frame}

    \subsection{Логические величины}

    \begin{frame}{Логические величины}
        \begin{block}{Конструкторы логической величины}
            \pause
            Две константы: \texttt{True} и \texttt{False}
        \end{block}
        \pause
        \begin{block}{Элиминатор логической величины}
            Вся информация --- это ложь или истина.
            Элиминатор: \pause \texttt{if}.
        \end{block} \pause
        \begin{block}{Законы для логической величины}
            \begin{enumerate}
                \item \pause \mintinline{python}|forall t e. if True: t else: e == t|
                \item \mintinline{python}|forall t e. if False: t else: e == e|
            \end{enumerate}
            \pause
            Или в случае лямбда-исчисления нам нужны термы \pause $\term{true}$, $\term{false}$ и $\term{if}$:
            \begin{enumerate}
                \item $\term{if} \ap \term{true} \ap T \ap E \eqbeta T$
                \item $\term{if} \ap \term{false} \ap T \ap E \eqbeta E$
            \end{enumerate}
        \end{block}
    \end{frame}

    \begin{frame}{Логические величины в $\lambda$-исчислении}
        \begin{block}{Законы логических величин}
            \begin{enumerate}
                \item $\term{if} \ap \term{true} \ap T \ap E \eqbeta T$
                \item $\term{if} \ap \term{false} \ap T \ap E \eqbeta E$
            \end{enumerate}
        \end{block}
        \pause
        \begin{itemize}
            \item Единственный способ различить термы --- апплицировать к чему-нибудь и посмотреть, к чему аппликация редуцируется
            \item[\then] То есть $\term{if} \termdef \pause \lambda b~t~e \ldotp b \ap \ldots$
            \item \pause А $\term{true}$ и $\term{false}$ --- какие-то термы с разным аппликативным поведением
            \item[\then] Возьмём $\term{true} \termdef \pause \term{K}$ и $\term{false} \termdef \term{K}^*$
            \item[\then] \pause $\term{if} \termdef \pause \lambda b~t~e\ldotp b \ap t \ap e \eqeta \pause \lambda x\ldotp x$
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Проверка законов логических величин}
        \begin{itemize}
            \item[\todo] Проверьте выполнение законов
            \item[\answer] \pause Для $\term{false}$ аналогично
            \begin{align*}
                \term{if} \ap &\term{true} \ap \framebox{T} \ap E
                \step_{\beta} \pause \\
                (\lambda b~t~e\ldotp b \ap t \ap e) \ap &\term{true} \ap T \ap E
                \step_{\beta} \pause \\
                &\term{true} \ap T \ap E
                \step_{\beta} \pause \\
                &\term{K} \ap T \ap E
                \step_{\beta} \pause \\
                &(\lambda x~y\ldotp x) \ap T \ap E
                \step_{\beta} \pause
                \framebox{T}
            \end{align*}
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Программирование операций над логическими величинами: отрицание}
        \pause
        \begin{center}
            \begin{tabular}{|c|c|}
                \hline
                $b$   & $\neg b$ \\ \hline
                true  & false    \\
                false & true     \\ \hline
            \end{tabular}
        \end{center}

        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{На Python}
                    \begin{minted}{python}
                        def notb(b): #\pause#
                            if b:
                                return False
                            else:
                                return True
                    \end{minted}
                \end{block}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{На лямбда-исчислении}
                    \[
                        \term{not}~\pause b\termdef \term{if} \ap b \ap \term{false} \ap \term{true}
                    \]
                    \vspace{-1em}
                \end{block}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Программирование операций над логическими величинами: конъюнкция}
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                $x$   & $y$   & $x \land y$ \\ \hline
                true  & true  & true        \\
                true  & false & false       \\
                false & true  & false       \\
                false & false & false       \\ \hline
            \end{tabular}
        \end{center}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{На Python}
                    \begin{minted}{python}
                        def andb(x, y): #\pause#
                            if x:
                                return y
                            else:
                                return False
                    \end{minted}
                \end{block}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{На лямбда-исчислении}
                    \[
                        \term{and} ~x~y \termdef \pause \term{if} \ap x \ap y \ap \term{false}
                    \]
                    \pause
                    Или бета-эквивалентный вариант:
                    \[\term{and}~x~y \termdef \lambda t~e\ldotp \pause x~(y~t~e)~e\]
                    \vspace{-1em}
                \end{block}
            \end{column}
        \end{columns}
    \end{frame}

    \subsection{Натуральные числа}

    \begin{frame}[fragile]{Натуральные числа $\mathbb{N} \coloneqq \{0, 1, 2, 3, \cdots\}$}
        \vspace{-0.5em}
        \begin{block}{Конструкторы}
            \pause
            \begin{description}
                \item[Первая аксиома Пеано:] ноль является натуральным числом ($\term{0}$)
                \item[Вторая аксиома Пеано:] число, следующее за натуральным, тоже
                натуральное ($\term{suc} \ap n$)
            \end{description}
        \end{block}
        \pause
        \vspace{-0.5em}
        \begin{block}{Элиминаторы}
            Воспользоваться натуральным числом --- \pause что-то сделать $n$ раз:
            \vspace{-1em}
            \begin{columns}[onlytextwidth]
                \begin{column}[t]{0.475\textwidth}
                    \begin{minted}[escapeinside=??]{python}
                        def natElim(?\pause?n, f, ini): ?\pause?
                            def iterate(i):
                                if i == 0:
                                    return ini
                                else:
                                    return f(iterate(i - 1))
                            return iterate(n)
                    \end{minted}
                \end{column}\hfill
                \pause%
                \begin{column}[t]{0.495\textwidth}
                    \begin{minted}[escapeinside=??]{python}
                        natElim(3, lambda x: 's' + x, 'z')
                        ?$\step$\pause? iterate(3)
                        ?$\step$\pause? f(iterate(2))
                        ?$\step$\pause? f(f(iterate(1))
                        ?$\step$\pause? f(f(f(iterate(0)))
                        ?$\step$\pause? f(f(f(ini)))
                        ?$\step$\pause? 's' + ('s' + ('s' + 'z'))
                        ?$\step$\pause? 'sssz'
                    \end{minted}
                \end{column}
            \end{columns}
        \end{block}
        \pause
        \vspace{-0.5em}
        \begin{block}{Законы для натуральных чисел}
            \vspace{-0.7em}
            \begin{columns}[onlytextwidth]
                \begin{column}{0.375\textwidth}
                    \begin{enumerate}
                        \item \pause $\forall f~ini\ldotp \term{natElim} \ap \term{0} \ap f \ap ini \eqbeta ini$
                    \end{enumerate}
                \end{column}\hfill%
                \begin{column}{0.595\textwidth}
                    \begin{enumerate}
                        \setcounter{enumi}{1}
                        \item \pause $\forall n~f~ini\ldotp \term{natElim} \ap (\term{suc} \ap n) \ap f \ap ini \eqbeta f \ap (\term{natElim} \ap n \ap f \ap ini)$
                    \end{enumerate}
                \end{column}
            \end{columns}
        \end{block}
    \end{frame}

    \begin{frame}{Числа Чёрча}
        \vspace{-0.5em}
        \begin{columns}[onlytextwidth]
            \begin{column}{0.385\textwidth}
                \begin{block}{Форма чисел Чёрча}
                    Снова закодируем элиминацию в самой структуре.
                    \[
                        \begin{array}{l l}
                            \term{0}            & \termdef \pause \lambda s~z\ldotp z                                                  \\ \pause
                            \term{1}            & \termdef \pause \lambda s~z\ldotp s~z                                                \\ \pause
                            \term{2}            & \termdef \pause \lambda s~z\ldotp s~(s~z)                                            \\ \pause
                            \vdots \\
                            \forall k, \term{k} & \termdef \lambda s~z\ldotp\underbrace{s~(s~( \cdots s~(}_k z\underbrace{))\cdots)}_k \\
                        \end{array}
                    \]
                \end{block}
            \end{column}\hfill
            \pause%
            \begin{column}{0.585\textwidth}
                \begin{block}{Конструирование чисел Чёрча}
                    \vspace{-1em}
                    \[
                        \begin{array}{l l}
                            \term{0} & \termdef \pause \lambda s~z\ldotp z                                                             \\
                            \term{suc} \ap n
                            & = \pause \lambda s~z\ldotp \underbrace{s~(s~(\cdots (s~(}_{n+1} z\underbrace{)\cdots ))}_{n+1}  \\
                            & = \pause \lambda s~z\ldotp s~(\underbrace{s~(\cdots (s~(}_n z\underbrace{)\cdots )}_n)
                            = \pause \lambda s~z\ldotp s~(n~s~z) \\ \pause
                            \term{suc} \ap n
                            & = \pause \lambda s~z\ldotp \underbrace{s~(s~(\cdots (s~(}_{n+1} z\underbrace{))\cdots ))}_{n+1} \\
                            & = \pause \lambda s~z\ldotp \underbrace{s~(\cdots~(s~(}_n s~z\underbrace{)\cdots )}_n)
                            = \pause  \lambda s~z\ldotp n~s~(s~z)
                        \end{array}
                    \]
                \end{block}
                \pause
                \begin{block}{Элиминирование чисел Чёрча}
                    \[
                        \begin{array}{l l l}
                            & \term{natElim} \pause \ap n \ap f \ap ini & \termdef n \ap f \ap ini
                            \\ \pause
                            \text{или} & \term{natElim} \pause & \termdef \term{id}
                        \end{array}
                    \]
                    \vspace{-1em}
                \end{block}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}{Операции над числами Чёрча: сложение}
        \begin{itemize}
            \item[\todo] Закодируйте сложение
            \item[\answer] \pause Это всё равно что $n$ раз увеличить $m$ на единицу: \\
            $\term{plus} ~n~m \termdef \term{natElim} \ap n~\textbf{suc}~m$
            \item[\answer] \pause Это всё равно что сначала отсчитать $m$, а потом от этого
            отсчитать $n$:
            $\term{plus}~n~m \termdef \lambda~s~z\ldotp n~s~(m~s~z)$
        \end{itemize}
    \end{frame}

    \begin{frame}{Операции над числами Чёрча: проверка чётности числа (1)}
        \begin{block}{Методология}
            \begin{enumerate}
                \item \pause Смотрим, как терм ведёт себя в базовых случаях
                \vspace{-1em}
                \begin{columns}[onlytextwidth]
                    \begin{column}[t]{0.46\textwidth}
                        \vspace{-0.5em}
                        \begin{align*}
                            \term{isEven}~\term{0}& \step_\beta \pause \term{true} \\ \pause
                            \term{isEven}~\term{1}& \step_\beta \term{false} \\
                            \term{isEven}~\term{2}& \step_\beta \term{true} \\
                            \ldots
                        \end{align*}
                    \end{column}\hfill%
                    \begin{column}[t]{0.51\textwidth}
                        \begin{itemize}
                            \item \pause Функция принимает два значения
                            \item \pause Первый раз --- $\term{true}$
                            \item \pause Далее значения чередуются
                        \end{itemize}
                    \end{column}
                \end{columns}
                \item \pause Вспоминаем, как воспользоваться числом: \pause
                \begin{columns}[onlytextwidth]
                    \begin{column}{0.46\textwidth}
                        \[
                            \term{natElim} \ap \term{3} \ap f \ap ini \step_{\beta} \pause f \ap (f \ap (f \ap ini))
                        \]
                    \end{column}\hfill%
                    \begin{column}{0.51\textwidth}
                        \vspace{-2em}
                        \begin{itemize}
                            \item \pause Требуется сконструировать подходящие $f$ и $ini$
                        \end{itemize}
                    \end{column}
                    \vspace{-1em}
                \end{columns}
            \end{enumerate}
        \end{block}
    \end{frame}

    \begin{frame}{Операции над числами Чёрча: проверка чётности числа (2)}
        \vspace{-0.7em}
        \begin{block}{Решение 1}
            \begin{itemize}
                \item \pause В качестве состояния \pause будем поддерживать пару значений
                \item \pause Начальное состояние: $\term{start} \termdef \pause \term{pair} \ap \term{true} \ap \term{false}$
                \item \pause Переход: \pause $\term{swap} \pause \ap (\term{pair} \ap x \ap y) \termdef \term{pair} \ap y \ap x$
                \begin{itemize}
                    \item \pause Или то же самое $\term{swap} \termdef \lambda p\ldotp \term{pair} \ap (\term{snd} \ap p) \ap (\term{fst} \ap p)$
                \end{itemize}
                \item \pause Всё вместе: \pause $\term{isEven} \ap n \termdef \pause \term{fst} \ap (\term{natElim} \ap n \ap \term{swap} \ap \term{start})$
            \end{itemize}
            \pause
            Проверка:
            \begin{itemize}
                \item \pause $\term{isEven} \ap \term{0} \step_\beta \pause \term{fst} \ap \term{start} \step_\beta \pause \term{true}$
                \item \pause $\term{isEven} \ap \term{3} \step_\beta \pause \term{fst} \ap (\term{swap} \ap (\term{swap} \ap (\term{swap} \ap \term{start}))) \step_\beta \pause \term{fst} \ap (\term{swap} \ap (\term{swap} \ap (\term{pair} \ap \term{false} \ap \term{true}))) \step_\beta \pause \term{fst} \ap (\term{pair} \ap \term{false} \ap \term{true}) \step_\beta \pause \term{false}$
            \end{itemize}
        \end{block}
        \vspace{-0.5em}
        \begin{block}{Решение 2}
            \begin{itemize}
                \item \pause Состояние: булево значение
                \item \pause Начальное значение: \pause $\term{true}$; \pause переход: \pause $\term{not}$
                \item \pause Всё вместе: \pause $\term{isEven} \ap n \termdef \pause \term{natElim} \ap n \ap \term{not} \ap \term{true}$
            \end{itemize}
        \end{block}
    \end{frame}


    \sectionplan{Материалы}

    \begin{frame}{Что посмотреть в транспорте}
        \begin{itemize}
            \item \href{https://youtu.be/oiUO1L4TOLI}{\color{blue} Функциональное программирование как предмет и метод теоретической информатики.}
            \item \href{https://youtu.be/YWelsG4mbik}{\color{blue} Podlodka \#279 --- Тьюринг-полнота | Виталий Брагилевский.}
            \item \href{https://elizarov.medium.com/immutability-we-can-afford-10c0dcb8351d}{\color{blue} Blogpost: Roman Elizarov: Immutability we can afford.}
        \end{itemize}
    \end{frame}

    \begin{frame}{Серьёзные материалы}
        \begin{itemize}
            \item \href{https://www.youtube.com/playlist?list=PL-_cKNuVAYAVX_q9XOKoFm95234G6YfOj}{\color{blue} Записи лекций Дениса Николаевича на МКН}
            \item \href{https://compscicenter.notion.site/compscicenter/b6dddf00bc7d497298179a3bdbdda375}{\color{blue}Памятка с полезностями от Computer Science Center}
            \item Книга: Ламбда-исчисление, Барендрегт
        \end{itemize}
    \end{frame}

\end{document}
