%! suppress = MissingImport
%! suppress = MissingLabel
%! suppress = LineBreak

% CLI args https://tex.stackexchange.com/a/1501
\newif\ifhandout
\input{flags}

\input{preamble-slides}

\title[1. Программирование в $\lambda$-исчислении]{Практика 1. Программирование в $\lambda$-исчислении}
\date{осень 2025}

\begin{document}

    \mymaketitle

    \begin{frame}{В предыдущих сериях}
        \begin{itemize}
            \item[\newtopic] Синтаксис $\lambda$-исчисления
            \item[\newtopic] Свободные и связанные переменные
            \item[\newtopic] Классические комбинаторы
            \item[\newtopic] Бета-редукция
            \item[\newtopic] $\alpha, \beta,\eta$-эквивалентности
        \end{itemize}
    \end{frame}

    \begin{frame}[noframenumbering]{Содержание}
        \tableofcontents
    \end{frame}

    \sectionplan{Метаинформация о курсе}

    \begin{frame}{Отчётность}
        \begin{itemize}
            \item Оценка за курс --- оценка за экзамен (успеваемость по практике тоже учитывается)
            \item Допуск на экзамен --- зачёт по всем домашкам и летучкам, кроме, может быть, двух
            \item Правила зачёта по домашкам расписаны в самих домашках
            \item Отчётность будет вестись в гугл-табличке, правила пользования:
            \begin{itemize}
                \item Не сравниваем свою успеваемость с другими и не переживаем
                \item Смотрим, к кому можно обратиться за помощью
                \item Перфекционизм --- зло
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Домашки}
        \begin{itemize}
            \item Выдаются на каждую неделю
            \item В конце семестра будет достаточно возможностей добрать баллов
            \item За частичные решения тоже даются баллы
            \item После пары старайтесь как можно скорее начать делать задания
            \item В начале каждой пары будет разбор
            \item[\NB] Не столь важно не конечное решение как процесс поиска
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Коммуникация online}
        \begin{itemize}
            \item Личка преподавателей в телеграме
            \item Общий чат в телеграме\footnote{Все ссылки на wiki.}
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Коммуникация offline}
        \begin{itemize}
            \item Лучше спросить сразу: ``потом'' не будет времени, и сил не прибавится
            \item Спрашивать --- ответственность и работа студентов
            \item Распределять время и оценивать уместность --- ответственность и работа преподавателя
            \item Если совсем трудно, пишите в чат/личку во время пары или подходите после пары
            \item На парах ``присутствуйте'', а не занимайтесь отвлечёнными делами
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Условные обозначения}
        \begin{description}
            \item [\popslide] --- дополнительная общеобразовательная информация, данная для контекста
            \item [\advancedslide] --- продвинутый материал, не обязательный для понимания в рамках курса
            \item[\practicalslide] --- заметки, полезные для практического применения
        \end{description}
    \end{frame}

    \sectionplan{$\lambda$-исчисление}

    \subsection{Синтаксис $\lambda$-исчисления}

    \begin{frame}{Синтаксис $\lambda$-исчисления}
        \pause
        Множество программ (термов) --- $\Lambda$, множество допустимых переменных --- $V$.

        Синтаксис задаётся индуктивным определением:
        \begin{description}
            \item[Переменные] $x \in \Lambda$, если $x \in V$ \hspace{2em}
            \begin{tikzpicture}
                \node [expr] (x) {x};
            \end{tikzpicture}
            \pause
            \item[Абстракция] $(\lambda x\ldotp M) \in \Lambda$, если $x \in V, M \in \Lambda$ \hspace{2em}
            \begin{tikzpicture}
                \node [expr] (lam) {$\lambda$};
                \node [decl] (x) [below right = of lam] {$x$};
                \node [subtree] (m) [below = of lam] {$M$};
                \draw[->] (m.north) -- (lam);
                \draw[->] (x) -- (lam);
            \end{tikzpicture}
            \pause
            \item[Аппликация] $(M~N) \in \Lambda$, если $M \in \Lambda, N \in \Lambda$ \hspace{2em}
            \begin{tikzpicture}
                \node [expr] (dog) {$@$};
                \node [subtree] (m) [below left= of lam] {$M$};
                \node [subtree] (n) [below right= of lam] {$N$};
                \draw[->] (m.north) -- (lam);
                \draw[->] (n.north) -- (lam);
            \end{tikzpicture}
        \end{description}
    \end{frame}

    \begin{frame}[fragile]{Опускаем скобочки}
        \begin{columns}[onlytextwidth]
            \begin{column}{0.55\textwidth}
                \[\lambda f \ap g\ldotp \lambda x\ldotp f~(g~x)\]
                \begin{itemize}
                    \item[\todo] Какие скобочки пропущены в этой записи?
                    \item[\todo] Можно ли опустить имеющиеся?
                    \item[\todo] Как выглядит дерево синтаксиса, соответствующее этому терму?
                    \item[\todo] Опустите скобочки $((((a)~b)~(c~d))~(e))$
                    \item[\todo] Опустите скобочки $(y)~(\lambda x\ldotp (x))$
                    \item[\todo] Опустите скобочки $(\lambda x\ldotp (\lambda y\ldotp (x~y)))~(a)~(b)$
                    \item[\todo] Опустите скобочки $\lambda x\ldotp (x ~(\lambda y\ldotp y)\ap z)$
                \end{itemize}
            \end{column}\hfill%
            \pause%
            \begin{column}{0.45\textwidth}
                \begin{center}
                    \begin{tikzpicture}
                        \node [expr] (lamf) {$\lambda$};
                        \node [decl] (f) [below right=of lamf] {$f$};
                        \node [expr] (lamg) [below  =of lamf] {$\lambda$};
                        \node [decl] (g) [below right= of lamg] {$g$};
                        \node [expr] (lamx) [below  =of lamg] {$\lambda$};
                        \node [decl] (x) [below right= of lamx] {$x$};
                        \node [expr] (apf) [below  =of lamx] {$@$};
                        \node [expr] (vf) [below left= of apf] {$f$};
                        \node [expr] (apg) [below right=of apf] {$@$};
                        \node [expr] (vg) [below left= of apg] {$g$};
                        \node [expr] (vx) [below right= of apg] {$x$};
                        \draw[->] (lamg) -- (lamf);
                        \draw[->] (lamx) -- (lamg);
                        \draw[->] (f) -- (lamf);
                        \draw[->] (g) -- (lamg);
                        \draw[->] (x) -- (lamx);
                        \draw[->] (apf) -- (lamx);
                        \draw[->] (apg) -- (apf);
                        \draw[->] (vf) -- (apf);
                        \draw[->] (vg) -- (apg);
                        \draw[->] (vx) -- (apg);
                    \end{tikzpicture}
                \end{center}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Свободные и связанные переменные}
        \begin{columns}[onlytextwidth]
            \begin{column}{0.55\textwidth}
                \[\lambda x\ldotp (\lambda x~y\ldotp x)\ap (x \ap y)\]
                \begin{itemize}
                    \item[\todo] Какие переменные свободные в этом терме?
                    \item[\todo] Какими связывателями связаны остальные?
                    \item[\todo] А для $\lambda x\ldotp x~ (\lambda z\ldotp x~ z)~ z$?
                    \item[\todo] А для $\lambda a\ldotp \lambda b\ldotp \lambda c\ldotp a ~b~ (b~ c)~ c$?
                    \item[\todo] А для $a ~(a~ b) ~\lambda a. a~ a$?
                    \item[\todo] А для $\lambda a\ldotp (\lambda b\ldotp a)\ap b$?
                \end{itemize}
            \end{column}\hfill%
            \pause%
            \begin{column}{0.45\textwidth}
                \begin{tikzpicture}
                    \node [expr] (lamx) {$\lambda$};
                    \node [decl] (x) [below right= of lamx] {$x$};
                    \draw[->] (x) -- (lamx);
                    \node [expr] (ap) [below= of lamx] {$@$};
                    \draw[->] (ap) -- (lamx);
                    % left
                    \node [expr] (lamxx) [below left= of ap, xshift=-0.5cm] {$\lambda$};
                    \draw[->] (lamxx) -- (ap);
                    \node [decl] (xx) [below right= of lamxx] {$x$};
                    \draw[->] (xx) -- (lamxx);
                    \node [expr] (lamy) [below= of lamxx] {$\lambda$};
                    \draw[->] (lamy) -- (lamxx);
                    \node [decl] (y) [below right= of lamy] {$y$};
                    \draw[->] (y) -- (lamy);
                    \node [expr] (vxx) [below= of lamy] {$x$};
                    \draw[->] (vxx) -- (lamy);
                    % right
                    \node [expr] (apl) [below right=of ap, xshift=0.5cm] {$@$};
                    \draw[->] (apl) -- (ap);
                    \node [expr] (vx) [below left=of apl] {$x$};
                    \node [expr] (vy) [below right=of apl] {$y$};
                    \draw[->] (vx) -- (apl);
                    \draw[->] (vy) -- (apl);
                \end{tikzpicture}
            \end{column}
        \end{columns}
    \end{frame}

%    \begin{frame}{Дополнительные синтаксические договорённости}
%        Снизим синтаксическую зашумлённость с помощью следующих договорённостей:
%        \begin{block}{Договорённость о введении синонимичных имён}
%            \begin{itemize}
%                \item Можем вводить синонимы для термов:
%                \[
%                    \term{B} \termdef \lambda f \ap g\ldotp \lambda x\ldotp f~(g~x)
%                \]
%                \item ``Комбинаторный'' синтаксис допустим:
%                \[
%                    \term{B} \ap f \ap g \termdef \lambda x\ldotp f~(g~x)
%                \]
%            \end{itemize}
%        \end{block}
%    \end{frame}

    \subsectionplan{Семантика $\lambda$-исчисления}

%    \begin{frame}[fragile]{\subsecname \popslide}
%        \pause
%        \begin{itemize}
%            \item Вычисление --- это переписывание выражений по правилам
%            \item Для $\lambda$-термов определяются правила переписывания
%            \item Если термы ``похожим'' образом переписываются, то они эквивалентны
%            \item Термы ``означают'' одно и то же, если эквивалентны
%            \item[\eg] $2+2$ и $1+3$ записаны по-разному, но ``означают'' одно и то же
%            \item Можно задать смысл терма как класс эквивалентности, в котором он находится
%            \item Класс можно задать ``особенным'' представителем (далее)
%        \end{itemize}
%    \end{frame}

    \begin{frame}[fragile]{Подстановка}
        \begin{block}{Определение}
            \begin{equation}
                \nonumber
                \begin{cases}
                [x \mapsto N]
                    ~ x \equiv N \\
                    [x \mapsto N] ~ y \equiv y \\
                    [x \mapsto N] ~ P ~ Q \equiv ([x \mapsto N] P) ~ ([x \mapsto N] Q) \\
                    [x \mapsto N] ~ \lambda x. ~ P \equiv \lambda x. ~ P \\
                    [x \mapsto N] ~ \lambda y. ~ P \equiv \lambda y. ~ [x \mapsto N] ~ P, & y \not\in FV(N) \\
                    [x \mapsto N] ~ \lambda y. ~ P \equiv \lambda y'. ~ [x \mapsto N] ~ ([y \mapsto y'] P), & y \in FV(N)
                \end{cases}
            \end{equation}
        \end{block}
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{itemize}
                    \item[\todo] $[x \mapsto y] ~ x ~ (\lambda y. ~ y ~ z)$
                    \item[\todo] $[x \mapsto y ~ z] ~ x ~ (\lambda y. ~ y ~ z)$
                    \item[\todo] $[y \mapsto x] ~ x ~ (\lambda y. ~ y ~ z)$
                    \item[\todo] $[z \mapsto x] ~ x ~ (\lambda y. ~ y ~ z)$
                    \item[\todo] $[z \mapsto x ~ y] ~ x ~ (\lambda y. ~ y ~ z)$
                \end{itemize}
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \begin{itemize}
                    \item[\answer] \pause $y ~ (\lambda y. ~ y ~ z)$
                    \item[\answer] \pause $y ~ z ~ (\lambda y. ~ y ~ z)$
                    \item[\answer] \pause $x ~ (\lambda y. ~ y ~ z)$
                    \item[\answer] \pause $x ~ (\lambda y. ~ y ~ x)$
                    \item[\answer] \pause $x ~ (\lambda y'. ~ y' ~ (x ~ y))$
                \end{itemize}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}{$\beta$-редукция --- применение функций}
        \pause
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                Находим редекс:
                \begin{center}
                    \begin{tikzpicture}
                        \node [expr] (top) {$\cdots$};
                        \node [hexpr] (ap) [below = of top] {$@$};
                        \node [hexpr] (lam) [below left = of ap] {$\lambda$};
                        \node [decl] (x) [below right = of lam] {$x$};
                        \node [subtree] (l) [below = of lam] {$M$};
                        \node [subtree] (r) [below right = of ap] {$N$};
                        \draw[->] (ap) -- (top);
                        \draw[->] (lam) -- (ap);
                        \draw[->] (l) -- (lam);
                        \draw[->] (r.north) -- (ap);
                        \draw[->] (x) -- (lam);
                    \end{tikzpicture}
                \end{center}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.485\textwidth}
                Сокращаем редекс:
                \begin{center}
                    \begin{tikzpicture}
                        \node [expr] (top) {$\cdots$};
                        \node [subtree] (bot) [below = of top] {$\subst{M}{x}{N}$};
                        \draw[->] (bot) -- (top);
                    \end{tikzpicture}
                \end{center}
            \end{column}
        \end{columns}
        \pause
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.3\textwidth}
                \begin{itemize}
                    \item[\todo] $\comb{I}\ap(\comb{K}\ap\comb{I})\ap\comb{I}$
                    \item[\todo] $\comb{B}\ap(\lambda x\ldotp x)\ap(\lambda x\ldotp x\ap x)\ap a$
                    \item[\todo] $\comb{B}\ap\comb{S}\ap\comb{K}$
                \end{itemize}
            \end{column}\hfill%
            \begin{column}[t]{0.7\textwidth}
                \begin{itemize}
                    \item[\answer] \pause $\step(\lambda x\ldotp x)\ap(\comb{K}\ap\comb{I})\ap\comb{I}\step (\comb{K}\ap\comb{I})\ap\comb{I} \step ((\lambda x~y\ldotp x)\ap\comb{I})\ap\comb{I} \step (\lambda y\ldotp \comb{I})\ap \comb{I} \step \comb{I}$
                    \item[\answer] \pause $\step (\lambda x\ldotp x)\ap((\lambda x\ldotp x\ap x)\ap a) \step (\lambda x\ldotp x)\ap(a\ap a) \step a\ap a$
                    \item[\answer] \pause $\step \lambda x\ldotp \comb{S}\ap(\comb{K} \ap x) \step \lambda x\ldotp\comb{S}\ap (\lambda y\ldotp x) \step \lambda x~g~z\ldotp (\lambda y\ldotp x)\ap z\ap (g\ap z) \step \comb{B}$
                \end{itemize}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Эквивалентности}
        Эквивалентны ли следующие термы?
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.4\textwidth}
                \begin{itemize}
                    \item[\todo] $x \eqt_{?} x$
                    \item[\todo] $x \eqt_{?} y$
                    \item[\todo] $\lambda x. ~ x \eqt_{?} \lambda y. ~ y$
                    \item[\todo] $\lambda x. ~ x \eqt_{?} (\lambda y. ~ y) \ap (\lambda x. ~ x)$
                    \item[\todo] $\lambda x ~ y. ~ x ~ y \eqt_{?} \lambda x. ~ x$
                \end{itemize}
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \begin{itemize}
                    \item[\answer] \pause синтаксическое равенство
                    \item[\answer] \pause нет
                    \item[\answer] \pause $\alpha$-эквивалентность
                    \item[\answer] \pause $\beta$-эквивалентность
                    \item[\answer] \pause $\eta$-эквивалентность
                \end{itemize}
            \end{column}
        \end{columns}
    \end{frame}

    \sectionplan{Кодирование данных в $\lambda$-исчислении}

    \subsection{Значения-записи (records, tuples)}

    \begin{frame}[fragile]{\subsecname}
        Одна сущность может описываться несколькими различными свойствами:
        \begin{itemize}
            \item Комментарий в соцсети: автор, пост, текст, количество лайков\ldots
            \item Котик: имя, мурлычность (очевидно)
        \end{itemize}
        \begin{block}{Пример: Python}
            \begin{minted}{python}
                class Cat:
                   def __init__(self, name, murlicity):
                      self.name = name
                      self.murlicity = murlicity
            \end{minted}
        \end{block}
        \begin{block}{Пример: C++}
            \begin{minted}{c}
                struct Cat {
                    string name;
                    int murlicity;
                };
            \end{minted}
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Что мы хотим от структуры данных?}
        \pause
        \vspace{-0.5em}
        \begin{block}{Конструкторы}
            Создают новые значения структуры данных:
            \begin{minted}{python}
                barsik = Cat(name = "barsik", murlicity = 4)
            \end{minted}
        \end{block}
        \pause
        \begin{block}{Элиминаторы}
            Получают (используют) информацию из структуры данных:
            \begin{minted}{python}
                barsik.murlicity
            \end{minted}
        \end{block}
        \pause
        \begin{block}{Мутаторы}
            Изменение информации в экземпляре структуры данных:
            \begin{minted}{python}
                barsik.murlicity = barsik.murlicity + 3
            \end{minted}
            \pause
            В ФП не принято пользоваться изменяемыми данными, и мутаторы не нужны\footnote{\href{https://elizarov.medium.com/immutability-we-can-afford-10c0dcb8351d}{\color{blue} Roman Elizarov: Immutability we can afford.}}:
            \begin{minted}{python}
                happyBarsik = Cat(name = barsik.name,
                                  murlicity = barsik.murlicity + 3)
            \end{minted}
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Моделируем котиков}
        \pause
        Фактически нужно научиться задавать пары (имя + мурлычность):
        \begin{block}{API пар}
            \begin{itemize}
                \item Терм-конструктор $\term{pair}$
                \item Элиминаторы $\term{fst}$ и $\term{snd}$
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Законы пар}
            \begin{enumerate}
                \item $\forall N~M\ldotp \term{fst}~(\term{pair}~N~M) \equiv_\beta N$
                \item $\forall N~M\ldotp \term{snd}~(\term{pair}~N~M) \equiv_\beta M$
            \end{enumerate}
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Кодируем котиков}
        \pause
        \begin{center}
            Эм. Как??
            \vspace{1em}

            \includegraphics[width=0.4\textwidth]{figs/wat}
        \end{center}
    \end{frame}

    \begin{frame}[fragile]{Пары в $\lambda$-исчислении}
        \begin{block}{Законы пар}
            \begin{enumerate}
                \item $\forall N~M\ldotp \term{fst}~(\term{pair}~N~M) \equiv_\beta N$
                \item $\forall N~M\ldotp \term{snd}~(\term{pair}~N~M) \equiv_\beta M$
            \end{enumerate}
        \end{block}
        \pause
        \begin{block}{Конструктор}
            \begin{itemize}
                \item Принимает аргументы
                \item Принимает функцию действующую на всей информации пары
                \item $\term{pair} \termdef \lambda x~y\ldotp \lambda f \ldotp f \ap x \ap y$
                \item Благодаря каррированности, термы вида $\lambda f\ldotp f \ap n \ap m$ можно считать парами
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Элиминаторы}
            \begin{itemize}
                \item $\term{fst} \termdef \pause \lambda p \ldotp p \ap \term{K}$
                \item $\term{snd} \termdef \pause \lambda p \ldotp p \ap \term{K}^*$
            \end{itemize}
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Проверка законов пар}
        \begin{itemize}
            \item[\todo] Проверьте, что реализация пар удовлетворяет законам
            \item[\todo] Определите конструктор и элиминаторы для тройки двумя способами, каким законам они должны удовлетворять?
            \item[\answer] \pause
            \begin{align*}
                \term{fst} \ap &(\term{pair} \ap \framebox{N} \ap M)
                \step_\beta \pause \\
                \term{fst} \ap &((\lambda x~y\ldotp \lambda f \ldotp f \ap x \ap y) \ap N \ap M)
                \step_\beta \pause \\
                \term{fst} \ap &(\lambda f \ldotp f \ap N \ap M)
                \step_\beta \pause \\
                (\lambda p \ldotp p \ap \term{K}) \ap &(\lambda f \ldotp f \ap N \ap M)
                \step_\beta \pause \\
                &(\lambda f \ldotp f \ap N \ap M) \ap \term{K}
                \step_\beta \pause \\
                &\term{K} \ap N \ap M \step_{\beta} \framebox{N}
            \end{align*}
            \item Теперь можно пользоваться правилом большого шага:
            \begin{equation*}
                \term{fst} \ap (\term{pair} \ap N \ap M) \sstep N
            \end{equation*}
            \item[\answer]
            \begin{itemize}
                \item Пара пар: $\term{triple} = \lambda x~y~z\ldotp \term{pair}\ap x\ap (\term{pair} \ap y \ap z)$; $\term{snd3} = \lambda p\ldotp \term{fst}\ap(\term{snd}\ap p)$
                \item Тройка тройка: $\term{triple} = \lambda x~y~z\ldotp\lambda f\ldotp f\ap x\ap y\ap z$; $\term{snd3} = \lambda p\ldotp p\ap(\lambda x~y~z\ldotp y)$
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Каррирование и раскаррирование}
        \begin{itemize}
            \item[\todo] Как выразить функцию многих аргументов?
            \item[\answer] \pause Пусть принимает кортеж аргументов!
            \item[\todo] Реализуйте ``переключение'' между стилями
            \item[\answer] \pause
            \[
                \begin{array}{l l}
                    \term{curry}   & \termdef \lambda f\ldotp \lambda a~b\ldotp f~ (\term{pair}~a~b)           \\
                    \term{uncurry} & \termdef \lambda f\ldotp \lambda p\ldotp f~ (\term{fst}~p)~(\term{snd}~p)
                \end{array}
            \]
        \end{itemize}
        \begin{center}
            \vspace{2em}
            \includegraphics[width=0.4\textwidth]{figs/curry}
        \end{center}
%        \begin{block}{Договорённость о распаковке}
%            Пусть пару можно разобрать сразу при получении:
%            \[\term{uncurry} \termdef \lambda f\ldotp \lambda (\term{pair} \ap a \ap b) \ldotp f \ap a \ap b\]
%            Или в комбинаторном синтаксисе:
%            \[\term{uncurry} \ap f \ap (\term{pair} \ap a \ap b) \termdef f \ap a \ap b\]
%        \end{block}
    \end{frame}

    \subsectionplan{Логические величины}

    \begin{frame}{Моделируем логические величины}
        \pause
        \begin{block}{API логических величин}
            \begin{itemize}
                \item Конструкторы: две константы $\term{true}$ и $\term{false}$
                \item Элиминатор: $\term{if}$
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Законы для логической величины}
            \begin{enumerate}
                \item $\term{if} \ap \term{true} \ap T \ap E \eqbeta T$
                \item $\term{if} \ap \term{false} \ap T \ap E \eqbeta E$
            \end{enumerate}
        \end{block}
    \end{frame}

    \begin{frame}{Логические величины в $\lambda$-исчислении}
        \begin{block}{Законы логических величин}
            \begin{enumerate}
                \item $\term{if} \ap \term{true} \ap T \ap E \eqbeta T$
                \item $\term{if} \ap \term{false} \ap T \ap E \eqbeta E$
            \end{enumerate}
        \end{block}
        \pause
        \begin{block}{Конструкторы}
            \begin{itemize}
                \item Принимают ноль аргументов (константы)
                \item Принимают два потенциальных результата, из которых выбирают нужный
                \item $\term{true} \termdef \pause \lambda t~e \ldotp t$ (или $\term{K}$)
                \item $\term{false} \termdef \pause \lambda t~e \ldotp e$ (или $\term{K}^*$)
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Элиминатор}
            \begin{itemize}
                \item Вся логика уже в значениях, осталось применить
                \item $\term{if} \termdef \pause \lambda b~t~e\ldotp b \ap t \ap e$
                \item Или даже $\term{if} \termdef \lambda x \ldotp x$ (или $\term{if} \termdef \term{id}$)
            \end{itemize}
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Проверка законов логических величин}
        \begin{itemize}
            \item[\todo] Проверьте выполнение законов
            \item[\answer] \pause
            \begin{align*}
                \term{if} \ap &\term{true} \ap \framebox{T} \ap E
                \step_{\beta} \pause \\
                (\lambda b~t~e\ldotp b \ap t \ap e) \ap &\term{true} \ap T \ap E
                \step_{\beta} \pause \\
                &\term{true} \ap T \ap E
                \step_{\beta} \pause \\
                &\term{K} \ap T \ap E
                \step_{\beta} \pause \\
                &(\lambda x~y\ldotp x) \ap T \ap E
                \step_{\beta} \pause
                \framebox{T}
            \end{align*}
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Программирование операций над логическими величинами: отрицание}
        \begin{center}
            \begin{tabular}{|c|c|}
                \hline
                $b$   & $\neg b$ \\ \hline
                true  & false    \\
                false & true     \\ \hline
            \end{tabular}
        \end{center}

        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{На Python}
                    \begin{minted}{python}
                        def notb(b): #\pause#
                            if b:
                                return False
                            else:
                                return True
                    \end{minted}
                \end{block}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{На $\lambda$-исчислении}
                    \pause
                    \[
                        \term{not}~ b\termdef \term{if} \ap b \ap \term{false} \ap \term{true}
                    \]
                    (подразумеваем $\term{not} \termdef \lambda b\ldotp \term{if} \ap b \ap \term{false} \ap \term{true}$)
                \end{block}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Программирование операций над логическими величинами: конъюнкция}
        \begin{center}
            \begin{tabular}{|c|c|c|}
                \hline
                $x$   & $y$   & $x \land y$ \\ \hline
                true  & true  & true        \\
                true  & false & false       \\
                false & true  & false       \\
                false & false & false       \\ \hline
            \end{tabular}
        \end{center}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{На Python}
                    \begin{minted}{python}
                        def andb(x, y): #\pause#
                            if x:
                                return y
                            else:
                                return False
                    \end{minted}
                \end{block}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{На $\lambda$-исчислении}
                    \[
                        \term{and} ~x~y \termdef \pause \term{if} \ap x \ap y \ap \term{false}
                    \]
                    \pause
                    Или эквивалентный вариант:
                    \[\term{and}~x~y \termdef \lambda t~e\ldotp \pause x~(y~t~e)~e\]
                    \vspace{-1em}
                \end{block}
            \end{column}
        \end{columns}
    \end{frame}

    \subsectionplan{Натуральные числа}

    \begin{frame}[fragile]{Натуральные числа $\mathbb{N} \coloneqq \{0, 1, 2, 3, \cdots\}$}
        \pause
        \begin{block}{API логических величин}
            \begin{description}
                \item[Первая аксиома Пеано:] ноль является натуральным числом ($\term{0}$)
                \item[Вторая аксиома Пеано:] число, следующее за натуральным, тоже
                натуральное ($\term{suc} \ap n$)
                \item[Элиминатор] Воспользоваться натуральным числом --- что-то сделать $n$ раз: $\term{natElim}$
            \end{description}
        \end{block}
        \pause
        \begin{block}{Законы для натуральных чисел}
            \begin{enumerate}
                \item $\forall f~ini\ldotp \term{natElim} \ap \term{0} \ap f \ap ini \eqbeta ini$
                \item $\forall n~f~ini\ldotp \term{natElim} \ap (\term{suc} \ap n) \ap f \ap ini \eqbeta f \ap (\term{natElim} \ap n \ap f \ap ini)$
            \end{enumerate}
        \end{block}
    \end{frame}

%    \begin{frame}[fragile]{Элиминация натуральных чисел на питоне}
%        \vspace{-1em}
%        \begin{columns}[onlytextwidth]
%            \begin{column}[t]{0.475\textwidth}
%                \begin{minted}[escapeinside=??]{python}
%                    def natElim(?\pause?n, f, ini): ?\pause?
%                        def iterate(i):
%                            if i == 0:
%                                return ini
%                            else:
%                                return f(iterate(i - 1))
%                        return iterate(n)
%                \end{minted}
%            \end{column}\hfill
%            \pause%
%            \begin{column}[t]{0.495\textwidth}
%                \begin{minted}[escapeinside=??]{python}
%                    natElim(3, lambda x: 's' + x, 'z')
%                    ?$\step$\pause? iterate(3)
%                    ?$\step$\pause? f(iterate(2))
%                    ?$\step$\pause? f(f(iterate(1))
%                    ?$\step$\pause? f(f(f(iterate(0)))
%                    ?$\step$\pause? f(f(f(ini)))
%                    ?$\step$\pause? 's' + ('s' + ('s' + 'z'))
%                    ?$\step$\pause? 'sssz'
%                \end{minted}
%            \end{column}
%        \end{columns}
%    \end{frame}

    \begin{frame}[fragile]{Конструирование чисел Чёрча}
        \pause
        \vspace{-0.5em}
        \begin{block}{Конструктор $\term{0}$}
            \begin{itemize}
                \item Принимает ноль аргументов (константа)
                \item Принимает действие, начальный элемент и возвращает начальный элемент
                \item $\term{0} \termdef \lambda s~z\ldotp z$
            \end{itemize}
        \end{block}
        \pause
        \begin{block}{Конструктор $\term{suc}$}
            \begin{itemize}
                \item Принимает один аргумент
                \item Принимает действие и начальный элемент, возвращает применение нужное число раз
            \end{itemize}
            \[
                \begin{array}{l l}
                    \term{suc} \ap n
                    & = \lambda s~z\ldotp \underbrace{s~(s~(\cdots (s~(}_{n+1} z\underbrace{)\cdots ))}_{n+1}  \\
                    & = \lambda s~z\ldotp s~(\underbrace{s~(\cdots (s~(}_n z\underbrace{)\cdots )}_n)
                    = \lambda s~z\ldotp s~(n~s~z) \\ \pause
                    \term{suc} \ap n
                    & = \lambda s~z\ldotp \underbrace{s~(s~(\cdots (s~(}_{n+1} z\underbrace{))\cdots ))}_{n+1} \\
                    & = \lambda s~z\ldotp \underbrace{s~(\cdots~(s~(}_n s~z\underbrace{)\cdots )}_n)
                    = \lambda s~z\ldotp n~s~(s~z)
                \end{array}
            \]
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Элиминация чисел Чёрча}
        \pause
        \begin{block}{Форма чисел Чёрча}
            Снова элиминация закодирована с самих значениях:
            \[
                \begin{array}{l l}
                    \term{0}            & \termdef \pause \lambda s~z\ldotp z                                                  \\ \pause
                    \term{1}            & \termdef \pause \lambda s~z\ldotp s~z                                                \\ \pause
                    \term{2}            & \termdef \pause \lambda s~z\ldotp s~(s~z)                                            \\ \pause
                    \vdots \\
                    \forall k, \term{k} & \termdef \lambda s~z\ldotp\underbrace{s~(s~( \cdots s~(}_k z\underbrace{))\cdots)}_k \\
                \end{array}
            \]
        \end{block}
        \pause
        \begin{block}{Элиминирование чисел Чёрча}
            Просто применить значение к аргументам:
            \[
                \begin{array}{l l l}
                    & \term{natElim} \ap n \ap f \ap ini & \termdef n \ap f \ap ini
                    \\
                    \text{или} & \term{natElim} & \termdef \term{id}
                \end{array}
            \]
            \vspace{-1em}
        \end{block}
    \end{frame}

    \begin{frame}{Операции над числами Чёрча: сложение}
        \begin{itemize}
            \item[\todo] Закодируйте сложение
            \item[\answer] \pause Это всё равно что $n$ раз увеличить $m$ на единицу: \\
            $\term{plus} ~n~m \termdef \term{natElim} \ap n~\textbf{suc}~m$
            \item[\answer] \pause Это всё равно что сначала отсчитать $m$, а потом от этого
            отсчитать $n$:
            $\term{plus}~n~m \termdef \lambda~s~z\ldotp n~s~(m~s~z)$
        \end{itemize}
    \end{frame}

    \begin{frame}{Операции над числами Чёрча: проверка чётности числа (1)}
        \begin{block}{Методология}
            \begin{enumerate}
                \item Смотрим, как терм ведёт себя в базовых случаях
                \vspace{-1em}
                \begin{columns}[onlytextwidth]
                    \begin{column}[t]{0.46\textwidth}
                        \vspace{-0.5em}
                        \begin{align*}
                            \term{isEven}~\term{0}& \step_\beta \term{true} \\
                            \term{isEven}~\term{1}& \step_\beta \term{false} \\
                            \term{isEven}~\term{2}& \step_\beta \term{true} \\
                            \ldots
                        \end{align*}
                    \end{column}\hfill%
                    \begin{column}[t]{0.51\textwidth}
                        \begin{itemize}
                            \item Функция принимает два значения
                            \item Первый раз --- $\term{true}$
                            \item Далее значения чередуются
                        \end{itemize}
                    \end{column}
                \end{columns}
                \item Вспоминаем, как воспользоваться числом:
                \begin{columns}[onlytextwidth]
                    \begin{column}{0.46\textwidth}
                        \[
                            \term{natElim} \ap \term{3} \ap f \ap ini \step_{\beta} f \ap (f \ap (f \ap ini))
                        \]
                    \end{column}\hfill%
                    \begin{column}{0.51\textwidth}
                        \begin{itemize}
                            \item Требуется сконструировать подходящие $f$ и $ini$
                        \end{itemize}
                    \end{column}
                \end{columns}
            \end{enumerate}
        \end{block}
    \end{frame}

    \begin{frame}{Операции над числами Чёрча: проверка чётности числа (2)}
        \vspace{-0.7em}
        \begin{block}{Решение 1}
            \begin{itemize}
                \item В качестве состояния будем поддерживать пару значений
                \item Начальное состояние: $\term{start} \termdef \term{pair} \ap \term{true} \ap \term{false}$
                \item Переход: $\term{swap} \termdef \lambda p\ldotp \term{pair} \ap (\term{snd} \ap p) \ap (\term{fst} \ap p)$
                \item  Всё вместе:  $\term{isEven} \ap n \termdef  \term{fst} \ap (\term{natElim} \ap n \ap \term{swap} \ap \term{start})$
            \end{itemize}
            \pause
            Проверка:
            \begin{itemize}
                \item $\term{isEven} \ap \term{0} \step_\beta  \term{fst} \ap \term{start} \step_\beta \term{true}$
                \item  $\term{isEven} \ap \term{3} \step_\beta  \term{fst} \ap (\term{swap} \ap (\term{swap} \ap (\term{swap} \ap \term{start}))) \step_\beta   \term{fst} \ap (\term{swap} \ap (\term{swap} \ap (\term{pair} \ap \term{false} \ap \term{true}))) \step_\beta  \term{fst} \ap (\term{pair} \ap \term{false} \ap \term{true}) \step_\beta  \term{false}$
            \end{itemize}
        \end{block}
        \vspace{-0.5em}
        \pause
        \begin{block}{Решение 2}
            \begin{itemize}
                \item Состояние: булево значение
                \item Начальное значение: $\term{true}$; переход: $\term{not}$
                \item Всё вместе: $\term{isEven} \ap n \termdef \term{natElim} \ap n \ap \term{not} \ap \term{true}$
            \end{itemize}
        \end{block}
    \end{frame}


    \sectionplan{Материалы \popslide}

    \appendix

    \begin{frame}[fragile]{Каррирование}
        \vspace{-0.5em}
        Эквивалентен ли код?
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \vspace{0.2 em}
                \[\textbf{K}^* \termdef \lambda x~y\ldotp y\]
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}
                    def k_star(x, y):
                        return y
                \end{minted}
            \end{column}
        \end{columns}
        \pause
        Нет:
        \vspace{-2em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \vspace{0.5em}
                \[\comb{K}^* \ap q \step_\beta (\lambda x~y\ldotp y) \ap q \step_\beta \lambda y\ldotp y \]
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}
                    > k_star(q)
                    TypeError: k_star() missing 1 required
                        positional argument: 'y'
                \end{minted}
            \end{column}
        \end{columns}
        \pause
        \vspace{0.3em}
        Правильная трактовка: ``$\comb{K}^*$ --- функция, которая игнорирует свой аргумент и возвращает
        функцию, которая возвращает свой аргумент'':
        \vspace{-1.5em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \vspace{0.5em}
                \[\lambda x~y\ldotp y \equiv \lambda x\ldotp \lambda y\ldotp y\]
            \end{column}\hfill
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}{python}
                    def k_star(x):
                        def helper(y):
                            return y
                        return helper
                \end{minted}
            \end{column}
        \end{columns}
        \pause
        \vspace{-0.5em}
        \begin{block}{Каррирование}
            Преобразование функции многих аргументов в набор вложенных функций, каждая из которых принимает часть аргументов исходной\footnote{В ООП методы класса каррированные --- часть их ``аргументов'' передаётся через конструктор.}.
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Замыкания\footnote{\url{https://groups.seas.harvard.edu/courses/cs153/2018fa/lectures/Lec12-Functions.pdf}}}
        Что если закодировать не $\comb{K}^*$, а $\comb{K}$:
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \vspace{0.5em}
                \[\comb{K} \termdef \lambda x\ldotp \lambda y\ldotp x\]
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \begin{minted}[escapeinside=??]{python}
                    def k(x):
                        def helper(y):
                            return ?\framebox{x}?
                        return helper
                \end{minted}
            \end{column}
        \end{columns}
        \pause
        \begin{block}{Замыкание (closure)}
            Пара из функции и окружения (состояния, к которому код функции имеет доступ).
            Используется в прикладных языках как эффективное представление $\lambda$-функций.
        \end{block}
        \pause
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{Ещё пример на Python}
                    \begin{minted}[escapeinside=??]{python}
                        screen = Screen(...)
                        def handler():
                            ?\framebox{screen}?.textField = ""
                        clearButton.onClick(handler)
                    \end{minted}
                \end{block}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{Ещё пример на C++}
                    \begin{minted}[escapeinside=??]{c++}
                        auto screen = Screen::create(...);
                        clearButton.onClick([screen]() {
                            ?\framebox{screen}?.textField = "";
                        });
                    \end{minted}
                \end{block}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Функции высших порядков}
        \begin{block}{Функция высших порядков (high-order functions, HOF)}
            Принимает другие функции в качестве аргументов.
        \end{block}
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{Пример на $\lambda$-исчислении}
                    \[\comb{B} \termdef \lambda \framebox{f} \ldotp \lambda \framebox{g} \ldotp \lambda x\ldotp f~(g~x)\]
                \end{block}
                \pause
                \begin{block}{Пример на Python}
                    На практике не всегда каррирование по всем аргументам оправдано:
                    \begin{minted}[escapeinside=??]{python}
                        def compose(?\framebox{f}?, ?\framebox{g}?):
                            def helper(x):
                                return f(g(x))
                            return helper
                    \end{minted}
                \end{block}
            \end{column}\hfill
            \pause%
            \begin{column}[t]{0.485\textwidth}
                \begin{block}{Пример на C++}
                    \begin{minted}[escapeinside=??]{c++}
                        function<int(int)> compose(
                            ?\framebox{function<int(int)> f}?,
                            ?\framebox{function<int(int)> g}?
                        ) {
                            return [f, g](int x) {
                                return f(g(x))
                            }
                        }
                    \end{minted}
                \end{block}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Законы и algebra driven design\footnote{Sandy Maguire, ``Algebra driven design''} \popslide}
        Закодировав пару, получили абстракцию по данным:
        \begin{itemize}
            \item Не два значения, а доменная сущность
            \item Можем выбрать произвольную реализацию, удовлетворяющую законам
            \item Можем забыть, как устроена реализация и разгрузить голову
            \item Можем в произвольный момент подменить реализацию на другую (например, на более эффективную), и пользовательский код не сломается
            \item Можем автоматически тестировать реализации на соответствие законам\footnote{\href{https://youtu.be/G0NUOst-53U?si=yrFoPQ-kSSPF1Xtb}{\color{blue} John Hughes - Keynote: How to specify it! (...) - Lambda Days 2020}}
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{``Кодирование наоборот''\footnote{``Наоборот'' также известно как tagless final, \href{https://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html}{\color{blue} church-boehm-berarducci encoding}, CPS transformation.} \popslide}
        \begin{itemize}
            \item Пусть функции не возвращают результат, а принимают способ его сразу обработать
            \item Функции не продают, но показывают
            \item ``Штуку я не дам, скажи, зачем она тебе, я всё сделаю''
            \item Вместо передачи объекта к месту деконструирования, передаём деконструирование к месту создания объекта
            \item Вместо \texttt{(X) -> R} теперь \texttt{(X, (R) -> a) -> a}
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Кодирование наоборот как оптимизация \popslide}
        \begin{itemize}
            \item Это общий способ избавления от аллокаций и структур данных
            \item Пример с HFT\footnote{High frequency trading --- очень быстро торгуют на бирже и зарабатывают деньги.} доклада --- оптимальный десериализатор:
            \begin{itemize}
                \item Есть два вида сообщений
                \item Десериализатор по-хорошему должен аллоцировать \texttt{std::variant}, но
            \end{itemize}
        \end{itemize}
        \begin{columns}[onlytextwidth]
            \begin{column}{0.485\textwidth}
                \begin{block}{С аллокацией}
                    \begin{minted}{cpp}
                        std::variant<Msg1, Msg2>
                            deserialize(bytes bs) {
                            if (...) {
                                return std::variant{Msg1(...)};
                            else {
                                return std::variant{Msg2(...)};
                            }
                        }
                    \end{minted}
                \end{block}
            \end{column}\hfill%
            \begin{column}{0.485\textwidth}
                \begin{block}{Без аллокации}
                    \begin{minted}{cpp}
                        template<class Impl>
                        auto deserialize(bytes bs) {
                            if (...) {
                                return Impl::processMsg1(...);
                            else {
                                return Impl::processMsg2(...);
                            }
                        }
                    \end{minted}
                \end{block}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}{Что посмотреть в транспорте}
        \begin{itemize}
            \item \href{https://youtu.be/oiUO1L4TOLI}{\color{blue} Функциональное программирование как предмет и метод теоретической информатики.}
            \item \href{https://youtu.be/YWelsG4mbik}{\color{blue} Podlodka \#279 --- Тьюринг-полнота | Виталий Брагилевский.}
            \item \href{https://elizarov.medium.com/immutability-we-can-afford-10c0dcb8351d}{\color{blue} Blogpost: Roman Elizarov: Immutability we can afford.}
            \item \href{https://compscicenter.notion.site/compscicenter/b6dddf00bc7d497298179a3bdbdda375}{\color{blue}Памятка с полезностями от Computer Science Center}
        \end{itemize}
    \end{frame}

    \begin{frame}{Серьёзные материалы}
        \begin{itemize}
            \item \href{https://www.youtube.com/playlist?list=PL-_cKNuVAYAVX_q9XOKoFm95234G6YfOj}{\color{blue} Записи лекций Дениса Николаевича на МКН}
            \item Книга: Ламбда-исчисление, Барендрегт
            \item \href{https://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html}{\color{blue} Beyond Church encoding: Boehm-Berarducci isomorphism of algebraic data types and polymorphic lambda-terms}
            \item \href{https://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html}{\color{blue} Church-boehm-berarducci encoding}
        \end{itemize}
    \end{frame}

\end{document}
