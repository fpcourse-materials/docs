Подобно тому, как в биологии теория эволюция является некоторым сквозным знанием, основой, скрепляющей разрозненные сведения о живом мире, этот курс будет считать интерпретаторы таким стержнем для теории языков программирования.
Это может показаться внезапным, так как, вроде бы, на практике люди пишут интерпретаторы довольно редко.
Опровергнем этот тезис и обоснуем выбор интерпретатора как краеугольного камня повествования.

\subsection{Башня интерпретаторов} \label{subsec:interpreters-tower}

Самым базовым интерпретатором является процессор, он воплощён физически в железе.
Ему на вход подаётся программа на некотором языке, например, x86, он зачитывает команды и превращает их в действия над памятью.
Однако, человеку крайне сложно программировать на этом языке, нужен новый язык, инкапсулирующий часть сложности и скрывающий лишние детали.

Чтобы получить новый язык, мы строим программный интерпретатор.
\vocab{Программный интерпретатор} $U_M^N$ --- это программа на языке $M$\footnote{Под языком мы тут понимаем множество программ на этом языке, иначе говоря, множество деревьев определённого вида.}, получающая на вход программу на языке $N$ и вход для неё --- данные из $D$, и возвращающая результат выполнения этой программы на этих данных: \[U_M^N : N\times D\to D\]

Про интерпретатор можно интуитивно думать следующим образом: это понятное мета-языку объяснение того, что значат конструкции определяемого языка.
Иными словами, какие инструкции мета-языка нужно исполнить, чтобы получить нужную семантику инструкций определяемого языка.

Например, у нас есть программа $p_N$ и данные для неё $d_{in}$, результат исполнения этой программы $d_{out}$ можно получить как \[d_{out} = U_M^N\left( \underbrace{\langle p_N, d_{in} \rangle}_{\in N\times D} \right)\]

Но интерпретатор это тоже программа.
Как её запустить?
Возьмём наш базовый интерпретатор $U^{x86}$, у него нет языка реализации, так как он реализован в железе, а не программно.
Возьмём интерпретатор языка ассемблера, реализованный в кодах x86, $U_{x86}^{Asm}$, программу на ассемблере $p_{Asm}$ и вход для неё $d_{in}$.
Вспомним, что программа --- это тоже данные, просто в некотором специальном формате.
Тогда результат применения $p_{Asm}$ на данных мы получим следующим образом:
\[
    d_{out} = U^{x86}\left(\left<\underbrace{U_{x86}^{Asm}}_{\in Asm}, \underbrace{\overbrace{\langle p_{Asm}}^{\in Asm}, \overbrace{d_{in} \rangle}^{\in D}}_{\in D} \right>\right)
\]

Но язык ассемблера, тоже не очень приятен для программирования.
Однако, на нем можно уже написать интерпретатор языка посложнее.
И так далее.
Получаем \point{башню интерпретаторов}, на вершине находится язык, на котором мы хотим уже решать непосредственно нашу задачу:
\[
    d_{out} =
    U^{x86}\left(\left<
                     U_{x86}^{Asm}, \left<
                                        U^C_{Asm}, \left<
                                                       U^{Has}_C, \left< p_{Has}, d_{in}
                \right>\right>\right>\right>\right)
\]

Иногда язык задают через трансляцию (компиляцию) в другой, но компилятор можно построить автоматически по интерпретатору\footnote{\href{https://habr.com/ru/articles/47418/}{Проекции Футамуры позволяют автоматически строить компиляторы по интерпретаторам.}}.

\subsection{Интерпретаторы повсюду} \label{subsec:interpreters-everywhere}

Хорошо, мы пришли к языку нашего сердца (Хаскеллу), почему же мы продолжаем говорить об интерпретаторах?
Потому что для решения конкретных бизнес-задач прикладные языки всё ещё слишком церемониальны~--- программисту приходится думать о большом количестве вещей, нерелевантных его предметной области и решаемой задаче.
Сложность~--- главный враг программиста, потому что ресурсы человеческого мозга несопоставимы со сложностью реальности, которую приходится описываться в программах.
Таким образом, в работе постоянно приходится описывать новые языки, наиболее подходящие для решения конкретных прикладных задач.
А новые языки мы задаём с помощью интерпретаторов.

Как выглядит классический рекурсивный интерпретатор?
Он получает программу в виде некоторого дерева и рекурсивно обходит его, считая результаты поддеревьев.
Когда он посещает вершину дерева, он определяет её тип и понимает, какие действия нужно исполнить.
То есть тип вершины диспатчит, навигирует, исполнение интерпретатора на нужный код.
Так, простой интерпретатор некоторого языка выражений мог бы иметь следующий вид:
\begin{minted}{haskell}
    eval :: Expr -> Int
    eval prog = case prog of
      Const x -> x
      Plus l r -> eval l + eval r
\end{minted}

Видно, что это похоже, например, на обработку вызова утилиты командной строки~--- разбираем аргументы, определяем, что и как нужно сделать, делаем.
Как ни странно, философия Unix, в частности, заключается в построении маленьких языков (утилит с текстовым API), решающих хорошо одну задачу~\cite{bentley1986little}.
Или это похоже на обработку запроса web-сервером~--- определяем ручку на которую пришел запрос, выполняем соответствующее действие.
То есть не так редко мы в реальной жизни пишем интерпретаторы.
Мы просто не видим, что то, что мы пишем --- это на самом деле интерпретатор некоторого языка.
В общем случае, свёртку структуры данных уже можно рассматривать как интерпретацию~\cite{gibbons2014folding}.

Более того, как мы убедимся в разделе~\ref{sec:wonder-interpreters}, написание любой функции~--- это уже задание нового языка.
Вот был язык, в котором нельзя было в приложение добавить пользователя.
Написали функцию \texttt{registerUser}~--- появилась новая команда в языке~--- добавить пользователя.
Далее мы формально покажем, то такой способ эквивалентен добавлению новой ноды в синтаксическое дерево языка.
Использование функций является примером встраивания языка, когда мы вместо того, чтобы делать новый отдельный язык, его реализуем как библиотеку для уже существующего языка~\cite{gibbons2013functional}.

Как мы будем более и более убеждаться по ходу этого курса, почти любую задачу можно свести к придумыванию языка и написанию интерпретатора.
Значит, если мы научимся писать интерпретаторы, мы научимся писать любые программы и решать любые задачи!
И основные наши усилия будут направлены на изучение средств построения интерпретаторов встроенных языков.

\subsection{Интерпретаторы и семантика языков программирования} \label{subsec:semantics}

Семантика языков программирования\footnote{\url{https://en.wikipedia.org/wiki/Semantics_(computer_science)}\label{note:sema-wiki}}\footnote{https://coq.vercel.app/ext/sf/}~--- это наука, изучающая смысл программ, его свойства и способы описания.
Отличным введением может послужить серия книг Software Foundations\footnote{\url{https://coq.vercel.app/ext/sf/}}~\cite{pierce2010software}.
Существует много различных стилей описания семантики программ, для нас важнейшим будет денотационная семантика.

\vocab{Денотационная семантика}\footnote{\url{https://en.wikipedia.org/wiki/Denotational_semantics}}\footnote{\url{https://en.wikibooks.org/wiki/Haskell/Denotational_semantics}}\footnote{\href{https://youtu.be/pQyH0p-XJzE?si=TUEzrpHhJZfO7dTF}{(youtube) The Lost Art of Denotational Semantics --- Eric Meyer.}} описывает смысл программ путём сопоставления им объектов некоторого множества, \vocab{семантического домена}.
Иначе говоря, денотационная семантика языка $L$ --- это тотальная функция из программы на этом языке в элемент домена $D$:
\[
    \sembr{\bullet} : L \mapsto D
\]

Домен выбирается исходя из языка и информации, которую хочется извлекать из программ.
Например, чтобы узнать размер программы (тут, выражения со сложением), в качестве домена можно взять натуральные числа:
\[
    \begin{array}{lcl}
        \sembr{n} & = & 1 \\
        \sembr{l + r} & = & \max{(\sembr{l}, \sembr{r})}
    \end{array}
\]
Если нас интересует конечный результат, можно посчитать его:
\[
    \begin{array}{lcl}
        \sembr{n} & = & n \\
        \sembr{l + r} & = & \sembr{l} + \sembr{r}
    \end{array}
\]
Если у программы есть вход, доменом будет функция $\mathbb{N}\to\mathbb{N}$:
\[
    \begin{array}{lcl}
        \sembr{n}(m) & = & n \\
        \sembr{l + r}(m) & = & \sembr{l}(m) + \sembr{r}(m) \\
        \sembr{input}(m) & = & m
    \end{array}
\]
Вариантов доменов много, это могут быть даже игры!\footnote{\url{https://en.wikipedia.org/wiki/Game_semantics}}

\begin{task}
    В какой домен разумно проинтерпретировать программы на языке с целочисленными мутабельными переменными?
    А для недетерминированного языка?
\end{task}

Легко заметить, что денотационная семантика языка --- это просто интерпретатор, только написанный на языке математики.
Мы также можем реализовывать интерпретатор на каком-нибудь реальном языке и он тоже будет задавать семантику определяемого языка.
Однако формальность такого определения будет зависеть от формальности описания семантики самого языка реализации интерпретатора~--- \vocab{мета-языка}.
Такие интерпретаторы называют ``\vocab{определяющими}'', они задают семантику языка, жертвуя эффективностью ради наглядности.
Взаимоотношения определяемого языка и мета-языка изучаются в классических статьях~\cite{reynolds1972definitional,reynolds1998definitional}\footnote{Активно используемое автором понятие продолжения будет рассмотрено далее в этом курсе (раздел \ref{sec:continuations}).}.

Мы будем использовать определяющие интерпретаторы для задания семантики новых языков и в качестве мета-языка будем использовать Haskell.
А в качестве доменов будем брать типы Haskell.
И интерпретировать программу не в множество функций между натуральными числами, а, скажем, в множество значений функционального типа \mintinline{haskell}|Nat -> Nat| в языке Haskell\footnote{\url{https://okmij.org/ftp/Denotational.html}}\footnote{Любому интересующемуся языками программирования предлагается провести на сайте Олега Киселёва не один месяц жизни: \url{https://okmij.org/ftp/README.html}.}.
Так, денотационная семантика языка сумм с входом будет записываться следующим образом:
\begin{minted}{haskell}
    eval :: Prog -> (Nat -> Nat)
    eval = \case
      Val n -> \_ -> n
      Plus l r -> \m -> eval l m + eval r m
      Input -> \m -> m
\end{minted}

Семантика называется \vocab{композиционной (compositional)}, если смысл конструкций зависит только от смысла подконструкций.
Иначе говоря, если денотационная семантика представляет собой свёртку программы (рис.\ \ref{fig:eval-prog}) и может быть записана в терминах катаморфизма~\ref{subsubsec:recursion-schemas}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{figs/eval-prog}
    \caption{Денотационная семантика определяет смысл синтаксических конструкций через операции над доменом~\cite{hutton1998fold}.}
    \label{fig:eval-prog}
\end{figure}

Другим популярным стилем описания семантики является \vocab{операционная семантика}, которая представляет смысл программы в виде последовательности шагов вычислений.
Это может быть как последовательное переписывание самого выражения, так и переписывание состояния некоторой абстрактной машины.
Операционная семантика, в свою очередь, задаётся как развёртка (или анаморфизм~\ref{subsubsec:recursion-schemas}) последовательности шагов вычисления из программы.
Тут отчётливо видна некоторая двойственность между денотационной и операционной семантиками~\cite{hutton1998fold}.






% todo expression problem
% todo Independently Extensible Solutions to the Expression Problem
