%! suppress = MissingImport
%! suppress = MissingLabel
%! suppress = LineBreak

% CLI args https://tex.stackexchange.com/a/1501
\newif\ifhandout
\input{flags}

\input{preamble-slides}
\setminted{xleftmargin=\parindent, autogobble, escapeinside=??}
\newcommand{\iso}{\sim}

\title{4. Типы данных}
\author{Андрей Стоян}
\institute[ИПКН ИТМО]{ИПКН ИТМО}

\date{осень 2025}

\begin{document}

    \mymaketitle

    \begin{frame}[noframenumbering]{Содержание}
        \tableofcontents
    \end{frame}

    \sectionplan{Вариантность}

    \begin{frame}[fragile]{(Ковариантный) функтор}
        \pause
        \begin{minted}{haskell}
            class Functor f where
              fmap :: (a -> b) -> (f a -> f b)
        \end{minted}
        \vspace{1em}
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.3\textwidth]{figs/functor}
        \end{figure}
    \end{frame}

    \begin{frame}[fragile]{Контравариантный функтор}
        \pause
        \begin{minted}{haskell}
            class Contravariant f where
              contramap :: (a -> b) -> (f b -> f a)
        \end{minted}
        \vspace{1em}
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.3\textwidth]{figs/contra-functor}
        \end{figure}
    \end{frame}

    \begin{frame}[fragile]{Знак позиции}
        \pause
        \begin{center}
            \begin{tabular}[h]{|c|c|c|}
                \hline
                Тип                              & знак позиции \mintinline{haskell}{A} & знак позиции \mintinline{haskell}{B} \\
                \hline
                \mintinline{haskell}{Either A B} & \pause $+$                                  & $+$                                  \\
                \mintinline{haskell}{(A, B)}     & \pause $+$                                  & $+$                                  \\
                \mintinline{haskell}{A -> B}     & \pause $-$                                  & $+$                                  \\
                \hline
            \end{tabular}
        \end{center}
        \vspace{1em}
        \begin{itemize}
            \item[\todo] \pause \mintinline{haskell}{f :: ((A, B) -> C) -> (D, E)}
            \item[\todo] \pause Объявите \mintinline{haskell}{instance Contravariant F} для \mintinline{haskell}{data F a = L (a -> ()) | R Int}.
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Всякие другие функторы}
        \pause
        \begin{minted}{haskell}
            class Bifunctor f where
              bimap :: (a -> c) -> (b -> d) -> f a b -> f c d
        \end{minted}

        \pause\vspace{1em}
        \begin{minted}{haskell}
            class Profunctor p where
              dimap :: (c -> a) -> (b -> d) -> p a b -> p c d

            dimap serialize deserialize (query :: Sql Text Text) :: Sql Age [User]
        \end{minted}
    \end{frame}

    \sectionplan{Изоморфизм}

    \begin{frame}[fragile]{Определение}
        \pause
        \begin{minted}{c}
    to . from = id
    from . to = id
        \end{minted}
        \vspace{1em}
        \pause
        \begin{minted}{haskell}
    to :: Bool -> Maybe ()
    to b = if b then Just () else Nothing

    from :: Maybe () -> Bool
    from m = case m of Nothing -> False; Just () -> True
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Кардинальность типа}
        \pause
        \begin{center}
            \begin{tabular}{|l|c|}
                \hline
                Тип и его декларация                                                                                                                                                                            & кардинальность \\
                \hline
                \mintinline{haskell}{data Void}                                                                                                                                                                 & $0$            \\
                \mintinline{haskell}{data Unit = Unit} & $1$ \\
                \mintinline{haskell}{data Bool = False | True}                                                                                                                                                  & $2$            \\
                \hline
            \end{tabular}
        \end{center}
        \pause
        \begin{center}
            \begin{tabular}{|l|c|}
                \hline
                Тип                                                      & кардинальность   \\
                \hline
                \mintinline{haskell}{data Either a b = Left a | Right b} & $|a| + |b|$      \\
                \mintinline{haskell}{data Pair a b = Pair a b}           & $|a| \times |b|$ \\
                \hline
            \end{tabular}
        \end{center}

        \vspace{1em}
        \pause
        \mintinline{haskell}|A -> B| изоморфно \[|A \to B| = |B|^{|A|}\]
    \end{frame}

    \begin{frame}[fragile]{Примеры}
        \pause
        \begin{itemize}
            \item \mintinline{haskell}{|Either Unit (Eigher Bool Bool)| ?\pause?= |Unit| + (|Bool| + |Bool|) = 5}.
            \item \mintinline{haskell}{Pair (Either Bool Unit) (Pair Unit Void)| ?\pause?= 0} ~--- тип \mintinline{haskell}|Void| не населён, как и кортеж, его включающий.
            \item Если \mintinline{haskell}{data Example = FirstAlternative Bool | AnotherOne Unit Bool Bool}, то \\\mintinline{haskell}{|Example| ?\pause?= |Bool| + |Unit| * |Bool| * |Bool| = 2 + 1 * 2 * 2 = 6}.
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Алгебраическое представление типа}
        \begin{center}
            \begin{tabular}{|p{0.5\textwidth}|c|}
                \hline
                Тип                                                      & алгебраическая формула      \\
                \hline
                \mintinline{haskell}{data Void}                          & $0$                         \\
                \mintinline{haskell}{data Unit = Unit}                   & $1$                         \\
                \mintinline{haskell}{data Bool = False | True}           & $1 + 1$ (обозначим как $2$) \\
                \mintinline{haskell}{data Maybe a = Nothing | Just a}    & $1 + a$                     \\
                \mintinline{haskell}{data Either a b = Left a | Right b} & $a + b$                     \\
                \mintinline{haskell}{data Pair a b = Pair a b}           & $a \times b$                \\
                \mintinline{haskell}{a -> b}                             & $b^a$                       \\
                \hline
            \end{tabular}
        \end{center}

        \pause\vspace{1em}
        Запишите в алгебраическом виде следующий тип:
        \begin{minted}{haskell}
        data T a b = Undefined | Defined a (a -> b)
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Школьная алгебра}
        \vspace{-1em}
        \begin{columns}[onlytextwidth]
            \begin{column}{0.485\textwidth}
                \begin{minted}{haskell}
            -- ?$(c^b)^a \iso c^{a\times b}$?
            to :: (a -> b -> c) -> (a, b) -> c
            to = uncurry
            from :: ((a, b) -> c) -> a -> b -> c
            from = curry
                \end{minted}
            \end{column}\hfill%
            \begin{column}[t]{0.485\textwidth}
                \pause\vspace{-1em}
                \begin{figure}[h]
                    \centering
                    \includegraphics[width=1\textwidth]{figs/school-alg}
                \end{figure}
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Больше алгебры}
        \pause
        \begin{itemize}
            \item[\todo] Покажите, что $(a + b) + c \iso a + (b + c)$.
            \item[\todo] Покажите, что $c^{a + b} \iso c^a\times c^b$.
        \end{itemize}
        \pause\vspace{1em}
        \begin{minted}{haskell}
            -- ?$a \times a \iso a^2$?
            get :: (a, a) -> (Bool -> a)
            get (x, y) idx = if idx then x else y
            tabulate :: (Bool -> a) -> (a, a)
            tabulate f = (f True, f False)
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Каноническое представление типа}
        \pause
        \[
            \sum_{i}\prod_{j} t_{ij}
        \]
    \end{frame}

    \sectionplan{Рекурсивные типы}

    \begin{frame}[fragile]{Рекурсивные типы}
        \begin{minted}{haskell}
            fac n = if n <= 1 then 1 else n * ?\framebox{fac}? (n - 1)
            data Nat = Zero | Suc ?\framebox{Nat}?
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Список через неподвижную точку}
        \pause
        \begin{minted}{haskell}
            type Shape a r = Either () (a, r) -- ?$\lambda a~r\ldotp 1 + a\times r$?
            data FixList a = FixList (Shape a (FixList a))
            -- FixList a ?$\iso$? Shape a (FixList a) ?$\iso$? Shape a (Shape a (FixList a)) ?$\iso$? ...
        \end{minted}
        \vspace{1em}
        \begin{minted}{haskell}
            data [a] = [] | a : [a]
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Свёртка}
        \pause
        \begin{center}
            \includegraphics[width=0.7\textwidth]{figs/foldr}
        \end{center}
        \pause
        \begin{minted}{haskell}
            foldr :: (Either () (a, r) -> r) -> FixList a -> r
            foldr phi (FixList shape) = case shape of
              Left () -> phi (Left ())
              Right (x, xs) -> phi (Right (x, foldr phi xs))
            -- сравните с классическим определением
            foldr :: r -> (a -> r -> r) -> [a] -> r
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Неподвижная точка функтора}
        \pause
        \begin{minted}{haskell}
            newtype Fix :: (Type -> Type) -> Type
            newtype Fix f = In { out :: f (Fix f) }

            data ListF a r = Nil | Cons a r
            type List a = Fix (ListF a)
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    to :: [a] -> List a
    to = \case
      [] -> In Nil
      x:xs -> In $ Cons x (to xs)

    from :: List a -> [a]
    from (In shape) = case shape of
      Nil -> []
      Cons x xs -> x : from xs
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Функтор формы}
        \pause
        \begin{minted}{haskell}
            instance Functor (ListF a) where
              fmap :: (rec -> other) -> ListF a rec -> ListF a other
              fmap f = \case
                Nil -> Nil
                Cons x xs -> Cons x (f xs)
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Катаморфизм}
        \pause
        \begin{minted}{haskell}
            cata :: Functor f => (f a -> a) -> Fix f -> a
            cata phi = phi . fmap (cata phi) . out
        \end{minted}
        \begin{figure}[h]
            \centering
            \includegraphics[width=0.8\textwidth]{figs/cataStep.excalidraw}
        \end{figure}
        \begin{minted}{haskell}
            sum :: List Int -> Int
            sum = cata \case
              Nil -> 0
              Cons x result -> x + result
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Алгебры}
        \pause
        \begin{minted}{haskell}
            data MonoidSig carrier = Mempty | Mappend carrier carrier

            interpretSig :: MonoidSig Int -> Int
            interpretSig = \case Mempty -> 0; Mappend l r -> l + r
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Анаморфизмы}
        \pause
        \begin{minted}{haskell}
            ana :: Functor f => (s -> f s) -> s -> Fix f
            ana psi = In . fmap (ana psi) . psi
            -- сравните с классическим определением развёртки списка
            unfoldr :: (s -> Maybe (a, s)) -> s -> [a]
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Гилеморфизмы}
        \pause
        \begin{minted}{haskell}
    hylo :: Functor f => (a -> f a) -> (f b -> b) -> a -> b
    hylo psi phi = cata phi . ana psi
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    fac n = hylo
      (\n -> if n > 0 then Cons n (n - 1) else Nil)
      (\case Nil -> 1; Cons n acc -> n * acc)
        \end{minted}
    \end{frame}

    \sectionplan{Всё через свёртки}

    \begin{frame}[fragile]{Всё через свёртки}
        \pause
        \begin{minted}{haskell}
    to :: Functor f => Fix f -> (forall a . (f a -> a) -> a)
    to = flip cata

    from :: (forall a . (f a -> a) -> a) -> Fix f
    from g = g In
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    data ListF elem rec = Nil | Cons elem rec

    xs1 :: Fix (ListF Int)
    xs1 = In (Cons 1 (In (Cons 2 (In (Cons 3 (In Nil))))))

    xs2 :: (ListF Int a -> a) -> a
    xs2 = \alg -> alg (Cons 1 (alg (Cons 2 (alg (Cons 3 (alg Nil))))))

    ghci> xs2 @Int \case Nil -> 0; Cons x acc -> x + acc
    6
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Список Чёрча}
        \pause
        \begin{align*}
            \text{\texttt{(ListF elem a -> a) -> a}}
            \iso a^{\displaystyle a^{\displaystyle 1 + elem\times a}}
            \iso a^{\displaystyle a\times a^{\displaystyle elem\times a}}
            \iso \left( a^{\displaystyle a} \right)^{\displaystyle \left(\left( a^{\displaystyle a}\right)^{\displaystyle elem}\right)} \\
            \iso \text{\texttt{a -> (elem -> a -> a) -> a}}
        \end{align*}
    \end{frame}

    \begin{frame}[fragile]{Дефорестация --- мотивация}
        \pause
        \begin{minted}{haskell}
    all p xs = and (map p xs)
    -- или fused версия
    all p [] = []
    all p (x:xs) = p x && all p xs
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Дефорестация}
        \begin{figure}
            \centering
            \includegraphics[width=0.6\textwidth]{figs/deforestation-examples}
        \end{figure}
    \end{frame}

    \begin{frame}[fragile]{List fusion}
        \pause
        \begin{minted}{haskell}
    {-# RULES
    "map/map" forall f g xs. map f (map g xs) = map (f . g) xs
      #-}
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    build :: (forall b . (a -> b -> b) -> b -> b) -> [a]
    build g = g (:) []
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    list123 :: [Int]
    list123 = build \s z -> s 1 (s 2 (s 3 z))

    map :: (a -> b) -> [a] -> [b]
    map f xs = build \s z -> foldr (\x acc -> s (f x) acc) z xs
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    foldr f ini (build g) ?$\equiv$? g f ini
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Дефорестация вручную}
        \pause
        \begin{figure}
            \centering
            \begin{tabular}{p{0.5\textwidth} rl}
                \begin{minipage}[t]{0.5\textwidth}
                    \begin{minted}{cpp}
                std::variant<Msg1, Msg2>
                    deserialize(bytes bs) {
                    if (...) {
                        return std::variant{Msg1(...)};
                    else {
                        return std::variant{Msg2(...)};
                    }
                }
                    \end{minted}
                \end{minipage}
                &
                \begin{minipage}[t]{0.5\textwidth}
                    \begin{minted}{cpp}
                template<class Impl>
                auto deserialize(bytes bs) {
                    if (...) {
                        return Impl::processMsg1(...);
                    else {
                        return Impl::processMsg2(...);
                    }
                }
                    \end{minted}
                \end{minipage}
            \end{tabular}
        \end{figure}
    \end{frame}

    \begin{frame}[fragile]{Visitor pattern}
        \pause
        \begin{minted}{haskell}
    data Tree a = Leaf | Node a [Tree a]
    foldTree :: Tree a -> r -> (a -> [r] -> r) -> r
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    data Visitor a r = Visitor { onLeaf :: r, onNode :: a -> [r] -> r }
    visitTree :: Tree a -> Visitor a r -> r
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    data Tree a = Tree { visit :: forall r . Visitor a r -> r }

    leaf :: Tree a
    leaf = Tree { visit = \Visitor{onLeaf} -> onLeaf }

    node :: a -> [Tree a] -> Tree a
    node x ts = Tree { visit = \v@Visitor{onNode} -> onNode x (map (`visit` v) ts) }
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Visitor pattern}
        \pause
        \begin{minted}{kotlin}
    interface Visitor<a, r> {
        fun onLeaf(): r
        fun onNode(x: a, subtrees: List<r>): r
    }

    interface Tree<a> {
        fun <r> visit(visitor: Visitor<a, r>): r
    }
    class Leaf : Tree<Nothing> {
        override fun <r> visit(visitor: Visitor<Nothing, r>): r = visitor.onLeaf()
    }
    class Node<a>(val value: a, val subtrees: List<Tree<a>>) : Tree<a> {
        override fun <r> visit(visitor: Visitor<a, r>): r =
            visitor.onNode(value, subtrees.map { it -> it.visit(visitor) })
    }
        \end{minted}
    \end{frame}

    \sectionplan{Всё через развёртку}

    \begin{frame}[fragile]{Всё через развёртку}
        \pause
        \begin{minted}{haskell}
    ana :: Functor f => forall s . (s -> f s) -> s -> Fix f
    ana psi = In . fmap (ana psi) . psi
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    ana :: Functor f => (exists s . (s, s -> f s)) -> Fix f
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    data Box f where
      --     exists s. (s,    s -> f s)
      Box :: forall s . s -> (s -> f s) -> Box

    ana' :: Functor f => Box f -> Fix f
    ana' (Box currSeed psi) =
      In $ (\nextSeed -> ana' (Box nextSeed psi)) <$> psi currSeed
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Изоморфизм}
        \pause
        \begin{minted}{haskell}
            to :: Fix f -> Box f
            to x = Box x out

            from :: Functor f => Box f -> Fix f
            from = ana'
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    nats :: Box (ListF Int)
    nats = Box 0 \curr -> Cons curr (curr + 1)
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Stream fusion}
        \pause
        \begin{minted}{haskell}
    data ListF a r = Nil | Cons a r
    type MyStream a = Box (ListF a) -- ?$\exists$?s . (s -> ListF a s, s)
    -- ?$\iso$?
    data Step a s = Done | Yield a s
    data Stream a where
      Stream :: forall s . (s -> Step a s) -> s -> Stream a

    stream :: [a] -> Stream a
    stream xs = Stream (\case [] -> Done; x:xs -> Yield x xs) xs

    unstream :: Stream a -> [a]
    unstream (Stream next s) = case next s of
      Done -> []
      Cons a s' -> a : unstream next s'
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Пример map}
        \begin{minted}{haskell}
    mapS :: (a -> b) -> Stream a -> Stream b
    mapS f (Stream next s) = Stream next' s
      where
        next' s = case next s of
          Done -> Done
          Yield x s' -> Yield (f x) s'
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Общий пайплайн}
        \pause
        \begin{enumerate}
            \item Мы пишем все функции работы со списками через стримы:
            \begin{minted}{haskell}
        map :: (a -> b) -> [a] -> [b]
        map f = unstream . map f . stream
            \end{minted}
            \item С помощью RULES задаём правило переписывания stream/unstream, двойственное foldr/build: \texttt{stream . unstream = id}.
            \item Далее справляются обычные компиляторные оптимизации.
        \end{enumerate}
    \end{frame}

    \begin{frame}[fragile]{Фильтрация стримов}
        \begin{minted}{haskell}
    data Step a s = Done | Skip s | Yield a s

    filterS :: (a -> Bool) -> Stream a -> Stream a
    filterS p (Stream next s) = Stream next' s
      where
        next' s = case next s of
          Done -> Done
          Skip s' -> Skip s'
          Yield a s' -> if p a then Yield a s' else Skip s'
        \end{minted}
    \end{frame}

    \sectionplan{Вездесущий дуализм}

    \begin{frame}[fragile]{Push vs pull streaming}
        \pause
        \begin{minted}{kotlin}
    events.observe(object : Observer<Event> {
        override fun onComplete() { .. }
        override fun onNext(elem: Event) { .. }
    })
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{Data vs codata}
        \pause
        \begin{minted}{haskell}
    data ListF a r = Nil | Cons a r
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
            data List a where
              List :: ListF a (List a) -> List a

            fold :: (ListF a r -> r) -> List a -> r
            fold alg xs = case xs of
              Fix Nil -> alg Nil
              Fix (Cons y ys) -> alg (Cons y (fold alg ys))
        \end{minted}
        \pause\vspace{1em}
        \begin{minted}{haskell}
    codata CoList a where
      force :: CoList a -> ListF a (CoList a)

    unfold :: (s -> ListF a s) -> s -> CoList a
    force (unfold coalg s) = case coalg s of
      Nil -> Nil
      Cons x s' -> Cons x (unfold coalg s')
        \end{minted}
    \end{frame}

    \begin{frame}[fragile]{OOP}
        \pause
        \begin{minted}[escapeinside=**]{kotlin}
    class List<a>(val layer: Pair<a, List<a>>?)

    fun <a, r> fold(alg: (Pair<a, r>?) -> r, xs: List<a>): r =
        if (xs.layer == null) alg(null)
        else alg(Pair(xs.layer.first, fold(alg, xs.list.second)))

    interface CoList<a> { fun force(): Pair<a, CoList<a>>? }

    fun <a, s> unfold(coalg: (s) -> Pair<a, s>?, ini: s): CoList<a> =
        object : CoList<a> {
            override fun force(): Pair<a, CoList<a>>? {
                val layer = coalg(ini)
                return if (layer == null) null else
                    Pair(layer.first, unfold(coalg, layer.second))
            }
        }
        \end{minted}
    \end{frame}

\end{document}
