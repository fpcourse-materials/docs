%! suppress = MissingLabel

Рассмотрим самую вершину башни интерпретаторов.
Там интерпретируется программа, которая сама по себе уже не является интерпретатором, а представляет собой API или UI запрос от внешнего мира.
Эта программа интерпретируется в некоторое преобразование данных $d_{in}\rightsquigarrow d_{out}$, которые в свою очередь уже не являются программой (поскольку им не даётся семантика).
Как выглядят эти преобразования, как их композиционно описывать?

\[
    d_{out} =
    U^{Has}\left(
    \left<
    U_{Has}^{API/UI},
    \left<
    p_{API/UI},
    d_{in}
    \right>
    \right>
    \right)
\]

\subsection{Персистентные структуры данных}

Структуры данных разделяют на \vocab{изменяемые (mutable)} и \vocab{неизменяемые (immutable)}.
Это классификация лишь по внутренней реализации, используются изменяемые ячейки памяти или нет.

По использованию выделают \vocab{эфемерные} и \vocab{персистентные} структуры данных.
После работы с эфемерной структурой, по той же ссылке может быть доступна другая структура.
\begin{minted}{kotlin}
    let xs = emptyMutableList<Int>()
    xs.add(42)
    print(xs)
\end{minted}

Работа с персистентными структурами порождает каждый раз новые ссылки, в то время как по старым доступна изначальная структура.
\begin{minted}{haskell}
    let xs = []
    let xs' = 42 : xs
    print xs'
\end{minted}

Может показаться, что эфемерные являются изменяемыми, а персистентные --- неизменяемыми.
На самом деле это более-менее ортогональные классификации.
Так, с помощью копирования можно к изменяемой структуре данных предоставить персистентный интерфейс, а неизменяемой --- эфемерный (с помощью монады \mintinline{haskell}|State|).

В речи, когда говорят о персистентных структурах данных, часто имеют в виду структуры данных с персистентным интерфейсом, специально оптимизированные для него (не требуют полного копирования на каждую операцию).
Способы построения таких структур и работы с ними на удивление довольно оптимальны и разнообразны~\cite{okasaki1999purely}.

Например, можно реализовать эффективный персистентный массив с логарифмической сложностью всех операций.
В Haskell такой структурой данных является \mintinline{haskell}|Seq|\footnote{\url{https://hackage.haskell.org/package/containers-0.7/docs/Data-Sequence.html}}\footnote{\url{http://www.staff.city.ac.uk/~ross/papers/FingerTree.html}}.
Если в вершинах хранить небольшие массивы, которые современные аритектуры процессоров могут эффективно копировать, можно существенно уменьшить высоту дерева и алгоритмическую сложность операций (e.g. \mintinline{scala}|scala.immutable.Vector|).

\begin{task}
    Реализуйте не Haskell персистентное декартово дерево по неявному ключу.
    Какие особенности Haskell усложняют использование этой структуры?
\end{task}

Когда использовать эфемерные, а когда персистентные структуры данных?
Если сравнивать, то можно обнаружить, что эфемерные можно реализовывать эффективнее во многих случаях, так как память изменяемая и кеши процессоров лучше работают с локальными данными (в то время как персистентные структуры обречены быть деревьями, чтобы реаллоцировать не структуру целиком, а только путь до корня).

Персистентные структуры же позволяют писать более модульный и безопасный с точки зрения многопоточности код, который может не учитывать возможность изменения структуры по ссылке.
В то время как работа с эфемерной структурой не является чистым кодом, а включает в себя порождение побочных эффектов.
Также объединение персистентными результатов разных вызовов может быть дешевле, как, например, конкатенация персистентных массивов дешевле конкатенации эфемерных (логарифмическая сложность против линейной).

Таким образом, в рамках ограниченного, легко обозреваемого скоупа лучше использовать эфемерные структуры ввиду их эффективности (например, чтобы изначально заполнить коллекцию элементами).
Однако, через границы абстракции лучше пропускать только персистентные структуры (или же положиться на систему эффектов, см.~\ref{sec:effect-systems}).
То есть каждая структура данных должна поддерживать две фазы своей жизни.
Например, так сделано в Scala, где у многих персистентных коллекций есть \mintinline{scala}|Builder| версия.

\subsection{Линзы}

Линзы являются простейшим примером оптики.
Исторически\footnote{\url{https://github.com/ekmett/lens/wiki/History-of-Lenses}}, первые линзы были придуманы, чтобы удобнее было работать с изменяемым состоянием при написании игры\footnote{\href{https://web.archive.org/web/20140402193032/https://lukepalmer.wordpress.com/2007/07/26/making-haskell-nicer-for-game-programming/}{(post) Making Haskell nicer for game programming}}\footnote{\href{https://web.archive.org/web/20120303223802/https://lukepalmer.wordpress.com/2007/08/05/haskell-state-accessors-second-attempt-composability/}{(post) Haskell State Accessors (second attempt: Composability)}}.




\subsection{Разнообразие оптических девайсов}

% todo there are pierce lenses

% todo http://www.timphilipwilliams.com/posts/2019-07-25-minecraft.html

% todo profunctor optics
% todo van laarhoven CPS optics

% todo internal iteration

% todo transducars

% todo слайды Беляева

% todo zippers

% todo generic optics and literals

% todo оптика как альтернатива стримам?

% todo
