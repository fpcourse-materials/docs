%! suppress = MissingLabel

Ранее мы признали работу со сложностью главной задачей программиста, а построение встроенных языков~--- основным инструментом этой работы (\ref{subsec:interpreters-rules}).
В данной главе же мы рассмотрим понятие эффекта.
Оно тесно связано со встроенными языками и даст нам лучшее понимание, когда их конструировать, что это даёт, и с чем нужно быть осторожным.

Для реализации встроенных языков мы предпочли shallow embedding в форме tagless final (\ref{subsec:tagless-final}), который максимально переиспользует возможности мета-языка и позволяет давать различные интерпретации одной программе.
Далее мы исследовали процесс вычисления и извлекли понятие продолжения (\ref{sec:continuations}).
Оказалось, что tagless final языки, которые мы строили вокруг монад, можно выразить через продолжения удобнее и проще (\ref{subsubsec:god-cont},\ \ref{subsubsec:monadic-reflection}).
В этой главе мы поймём, как это поможет решить expression problem (\ref{subsec:expression-problem}) до конца.

\subsection{Понятие эффекта} \label{subsec:about-effects}

Начнём разговор от обратного, со свойства чистоты.
\vocab{Чистая функция} обладает следующими свойствами:
\begin{itemize}
    \item Её результат всегда одинаков при одинаковом наборе аргументов (никак более нетривиально не зависит ни от чего более);
    \item Её единственный наблюдаемый результат --- её возвращаемое значение.
\end{itemize}

% todo obsidian What is a purely functional language?

В целом стиль программирования с использованием чистых функций приветствуется, так как он обладает множеством хороших свойств.
Так, про них можно удобно рассуждать с помощью equational reasoning; всё, что нужно для понимания кода, явно написано в этом коде; классические системы типов хорошо работают, предоставляя полноту абстракции, качественную документацию и частичную спецификацию\ldots
Также известно, что всё можно записать с помощью чистых вычислений, даже работу с IO~\cite{jones2001tackling}.

Однако, используя только чистые функции, всё приходится делать вручную.
В случае с IO (с состоянием аналогично) --- передавать результирующий мир в аргументы раз за разом:
\begin{minted}{haskell}
    getList :: Int -> World -> (World, [Int])
    getList n w | n == 0 = (w, [])
                | otherwise =
      let (w', x) = getInt w in
      let (w'', xs) = getList (n - 1) w' in
      (w'', x : xs)
\end{minted}

Таким образом, код из чистых функций заполнен несущественными церемониями, за которыми не видно бизнес-логики и сути.
Чтобы сосредоточиться на важных деталях, нужно делегировать весь этот bookkeeping стороннему коду, замести неинтересные детали под ковёр.
Тогда код выше можно будет переписать, например, следующим образом:
\begin{minted}{haskell}
    getList :: Int -> IO [Int]
    getList n | n == 0 = pure []
              | otherwise = do
      x <- getInt
      xs <- getList (n - 1)
      return (x : xs)
\end{minted}

Абстрактную сущность, которой мы будем делегировать несущественные для данного фрагмента бизнес-логики детали, мы будем называть \vocab{контекстом исполнения (execution context)}\footnote{\url{https://okmij.org/ftp/Computation/having-effect.html} \label{lab:having-effect}}.
А \vocab{эффектом}~--- взаимодействие функции с контекстом исполнения, которое происходит с помощью вызова \vocab{effectful операций} (например, \texttt{getInt} из примера выше).
Так, на контекст исполнения можно смотреть как на сервер, которому функция-клиент шлёт запросы и получает ответы (см.\ рис.\ \ref{fig:effect-server}).
В этой модели такая функция может нарушать оба свойства чистых функций.

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{figs/effects}
    \caption{Эффекты как клиент-серверное взаимодействие.}
    \label{fig:effect-server}
\end{figure}

На практике этим контекстом является интерпретатор (встроенного) языка, а effectful операциями --- его конструкции.
Если язык является встроенным, то говорят о \vocab{пользовательских (user-defined) эффектах}.
Так мы снова возвращаемся к задаче построения модульных интерпретаторов (\ref{subsec:expression-problem}).
К тому же, реализация вычислительного контекста также может делегировать реализацию некоторой функциональности другому контексту исполнения, и так далее.
Получаем уже знакомую нам башню интерпретаторов (\ref{subsubsec:interpreters-tower}).

Рассмотрим некоторые примеры вычислительных контекстов и операций:
\begin{itemize}
    \item Контекст --- подсистема управления памятью, \texttt{modify} --- effectful операция: контекст для нас поддерживает состояние ячеек памяти;
    \item Контекст~--- хендлер исключения, \texttt{throw MyException}~--- effectful операция: контекст за нас определяет, как ошибка будет обрабатываться (обратите внимание, что тут управление не возвращается терму);
    \item Контекст~--- настройки инъекции зависимостей, запрос функциональности (\texttt{asks registerUser})~--- effectful операция: контекст за нас определяет реализацию функциональности, которой нам пользоваться\footnote{Существует термин \vocab{contextual polymorphism}~--- код в разных контекстах может иметь различное поведение.}.
    Как мы увидим далее, этот и подобные простые эффекты можно реализовать просто и эффективно (см.\ \ref{subsubsec:evidence-passing}).
\end{itemize}

\begin{task}
    Приведите ещё примеры вычислительных контекстов и операций.
\end{task}

Когда мы говорим про standalone язык, на котором мы программируем (например, Haskell), любое наше действие в программе исполняется им.
То есть, например, сложение --- effectful операция?
В таком случае разумно выделить подмножество конструкций языка, достаточно ``интересных'', чтобы считать, что они порождают эффект.

Какие конструкции языка считать ``интересными''?
Заметим, что с одной стороны это хорошо, что эффекты скрывают от нас некоторую сложность, позволяя сосредоточиться на других вещах.
С другой стороны, это же и плохо, ведь мы эту сложность перестаём наблюдать, а она пронизывает наш код, поддерживает неявные зависимости между его частями.
Таким образом, эффекты требуют дополнительной аккуратности со стороны программиста\footnote{\href{https://youtu.be/_nG09Z_tdUU?si=lo9It6299rsB1vAr}{(youtube) Kris Jenkins --- Side-Effects Are The Complexity Iceberg.}}.
Соответственно, именно такие непростые конструкции и стоит считать ``интересными''.
Как минимум точно стоит считать ``интересными'' конструкции, использование которых выводит функцию из категории чистых.
Также, это могут быть операции, делающие сложные нелокальные модификации потока управления (поддерживаемого интерпретатором в виде продолжения).

В конечном итоге выбор ``интересных'' конструкций зависит от задачи и перспективы разработчика\footref{lab:having-effect}.
Так, конструкции, влияющие на произвольные наблюдаемые свойства кода, как, например, терминируемость или сложность, могут мотивировать считать рекурсивные вызовы или долгие операции эффектами.

Далее мы научимся отслеживать и контролировать использование эффектов на уровне типов с помощью систем эффектов (см.\ далее\ \ref{sec:effect-systems}).

\subsection{Хендлеры эффектов} \label{subsec:effect-handlers}




% todo языка никогда не хватает, и хочется минимизировать ядро
% todo в зависимости от сложности, эффективность реализации тоже отличается

% todo историческая справка

\subsubsection{Client-server communication}

% todo \cite{Extensible effects}

\begin{minted}{haskell}
    data Request res = Val res | Ask (Int -> Request res)

    newtype Eff res = Eff { runEff :: forall res' . (res -> Request res') -> Request res' }
      deriving Functor

    instance Applicative Eff where
      pure x = Eff \k -> k x
      (<*>) = ap

    instance Monad Eff where
      comp >>= k = Eff \k' -> runEff comp \x -> runEff (k x) k'

    ask :: Eff Int
    ask = Eff \k -> Ask k

    run :: Eff res -> Request res
    run comp = runEff comp Val

    runReader :: Eff res -> Int -> res
    runReader comp env = loop (run comp)
      where
        loop = \case
          Val res -> res
          Ask k -> loop (k env)

    exampleReader :: Int -> Int
    exampleReader = runReader do
      x <- ask
      y <- ask
      pure (x + y)
\end{minted}

\begin{minted}{haskell}
data (e |> es) a = L (e a) | R (es a)
  deriving Functor

-- Codensity (Request es)
newtype Eff es res = Eff { runEff :: forall res'. (res -> Request es res') -> Request es res' }
  deriving Functor

instance Applicative (Eff es) where
  pure x = Eff \k -> k x
  (<*>) = ap

instance Monad (Eff es) where
  Eff comp >>= k = Eff \k' -> comp \x -> runEff (k x) k'

data Request es res = Val res | Msg (es (Request es res))

send
  :: (forall res'. (res -> Request es res') -> es (Request es res'))
  -> Eff es res
send f = Eff \k -> Msg (f k)

run :: Eff es res -> Request es res
run (Eff f) = f Val


newtype Reader e k = Ask (e -> k)
  deriving Functor

ask :: Eff (Reader e |> es) e
ask = send \k -> L $ Ask k

runReader
  :: forall es env res . Functor es
  => Eff (Reader env |> es) res
  -> env -> Eff es res
runReader comp env = loop (run comp)
  where
    loop :: Request (Reader env |> es) res -> Eff es res
    loop = \case
      Val res -> pure res
      Msg (L (Ask k)) -> loop (k env)
      Msg (R unknownReq) -> do
        response <- resend unknownReq
        loop response

    resend
      :: es (Request (Reader env |> es) res)
      -> Eff es (Request (Reader env |> es) res)
    resend unknownReq = send \k -> fmap k unknownReq
\end{minted}

% todo

\subsubsection{Free monads}

% todo free folk in general

% todo Stackless Scala with free monads
% todo freer monads
% todo iteratee O. Kiselyov. Iteratees. In Proc. of the 11th International Symposium on Functional and Logic Programming, pages 166–181, 2012.

% todo deep vs shallow handlers

% todo

\subsubsection{Хендлеры через ограниченные продолжения}

% todo deep vs shallow handlers

% todo

\subsubsection{Эффективная реализация хендлеров} \label{subsubsec:evidence-passing}

% todo стратегии компиляции

% todo функция это тоже способ унести код куда-то, обобщённый алгебраический эффект отличается более тонким контролем над континуэйшеном места вызова

% todo

\subsubsection{Приложения хендлеров}

% todo  custom schedulers

% todo связь с codata

% todo

\subsection{Трансформеры монад}

% TODO\cite{liang1995monad}

% todo remind of tagless final

% todo lift - monad morphism

% todo ContT, lift = (>>=)

% todo fused effects and CPS

% todo

\subsection{Алгебраичность и эффекты высших порядков}

% todo abstracting definitional interpreters & github semantics

% todo Monads and algebras

% todo https://www.eff-lang.org/handlers-tutorial.pdf

% todo


% todo compare open type families & extensible interpreters

% todo Polymorphic Symmetric Multiple Dispatch with Variance
% todo \textit{multimethods}
%    Languages with \textit{multimethods}, like Common Lisp’s CLOS, Dylan, and Julia do support adding both new types and operations easily.
%    What they typically sacrifice is either static type checking, or separate compilation.

% todo ZIO, TS Effect

% todo call-by-push value and how it is related to effects

% todo порядок интерпретаторов и interleaving of effects

% todo abstracting definitional interpreters, github semantics

% todo сравните хендлеры с генераторами ранее
